<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head><title>/usr/home/jlouis/hacking/test_server/stdlib_test/ets_tough_SUITE.erl</title></head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
    1:<i>%% ``The contents of this file are subject to the Erlang Public License,</i>
    2:<i>%% Version 1.1, (the "License"); you may not use this file except in</i>
    3:<i>%% compliance with the License. You should have received a copy of the</i>
    4:<i>%% Erlang Public License along with this software. If not, it can be</i>
    5:<i>%% retrieved via the world wide web at http://www.erlang.org/.</i>
    6:<i>%% </i>
    7:<i>%% Software distributed under the License is distributed on an "AS IS"</i>
    8:<i>%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See</i>
    9:<i>%% the License for the specific language governing rights and limitations</i>
<a name="10"></a>   10:<i>%% under the License.</i>
   11:<i>%% </i>
   12:<i>%% The Initial Developer of the Original Code is Ericsson Utvecklings AB.</i>
   13:<i>%% Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings</i>
   14:<i>%% AB. All Rights Reserved.''</i>
   15:<i>%% </i>
   16:<i>%%     $Id$</i>
   17:<i>%%</i>
   18:-<b>module</b>(ets_tough_SUITE).
   19:-<b>export</b>([all/1,ex1/1]).
<a name="20"></a>   20:-<b>export</b>([init/1,terminate/2,handle_call/3,handle_info/2]).
   21:-<b>export</b>([init_per_testcase/2, fin_per_testcase/2]).
   22:-<b>compile</b>([export_all]).
   23:-<b>include</b>("test_server.hrl").
   24:
<a name=all>   25:<b>all</b></a>(suite) -&gt; {req,[stdlib],[ex1]}.
   26:
   27:
   28:-<b>define</b>(DEBUG(X),debug_disabled).
   29:<i>%%-define(DEBUG(X),X).</i>
<a name="30"></a>   30:-<b>define</b>(GLOBAL_PARAMS,ets_tough_SUITE_global_params).
   31:
<a name=init_per_testcase>   32:<b>init_per_testcase</b></a>(Func, Config) -&gt;
   33:    Dog=test_server:timetrap(test_server:seconds(300)),
   34:    [{watchdog, Dog}|Config].
   35:
<a name=fin_per_testcase>   36:<b>fin_per_testcase</b></a>(Func, Config) -&gt;
   37:    Dog=?config(watchdog, Config),
   38:    test_server:timetrap_cancel(Dog),
   39:    ets:delete(?GLOBAL_PARAMS).
<a name="40"></a>   40:
   41:
<a name=ex1>   42:<b>ex1</b></a>(suite) -&gt; {req,{time,60}};
<a name=ex1>   43:<b>ex1</b></a>(Config) when list(Config) -&gt;
   44:    ?line ets:new(?GLOBAL_PARAMS,[named_table,public]),
   45:    ?line ets:insert(?GLOBAL_PARAMS,{a,set}),
   46:    ?line ets:insert(?GLOBAL_PARAMS,{b,set}),
   47:    ?line ex1_sub(Config),
   48:    ?line ets:insert(?GLOBAL_PARAMS,{a,ordered_set}),
   49:    ?line ets:insert(?GLOBAL_PARAMS,{b,set}),
<a name="50"></a>   50:    ?line ex1_sub(Config),
   51:    ?line ets:insert(?GLOBAL_PARAMS,{a,ordered_set}),
   52:    ?line ets:insert(?GLOBAL_PARAMS,{b,ordered_set}),
   53:    ?line ex1_sub(Config).    
   54:    
   55:    
   56:
   57:
<a name=ex1_sub>   58:<b>ex1_sub</b></a>(Config) -&gt;
   59:    {A,B} = prep(Config),
<a name="60"></a>   60:    N = 
   61:	case ?config(ets_tough_SUITE_iters,Config) of
   62:	    undefined -&gt;
   63:		5000;
   64:	    Other -&gt; 
   65:		Other
   66:	end,
   67:    {NewA,NewB} = run({A,B},N),
   68:    Gurkor = lists:keysearch(gurka,1,ets:all()),
   69:    (catch stop(NewA)),
<a name="70"></a>   70:    (catch stop(NewB)),
   71:    ok.
   72:
<a name=prep>   73:<b>prep</b></a>(Config) -&gt;
   74:    random:seed(),
   75:    put(dump_ticket,none),
   76:    DumpDir = filename:join(?config(priv_dir,Config), "ets_tough"),
   77:    file:make_dir(DumpDir),
   78:    put(dump_dir,DumpDir),
   79:    process_flag(trap_exit,true),
<a name="80"></a>   80:    {ok, A} = start(a),
   81:    {ok, B} = start(b),
   82:    {A,B}.
   83:
<a name=run>   84:<b>run</b></a>({A,B},N) -&gt;
   85:    run(A,B,0,N).
   86:
<a name=run>   87:<b>run</b></a>(A,B,N,N) -&gt;
   88:    {A,B};
<a name=run>   89:<b>run</b></a>(A,B,N,M) -&gt;
<a name="90"></a>   90:    eat_msgs(),
   91:    Op = random_operation(),
   92:    ?DEBUG(io:format("~w: ",[N])),
   93:    case catch operate(Op,A,B) of
   94:	{'EXIT',Reason} -&gt;
   95:	    io:format("\nFAILURE on ~w: ~w, reason: ~w\n",[N,Op,Reason]),
   96:	    exit(failed);
   97:	{new_a,NewA} -&gt;
   98:	    run(NewA,B,N+1,M);
   99:	_ -&gt;
<a name="100"></a>  100:	    run(A,B,N+1,M)
  101:    end.
  102:
<a name=eat_msgs>  103:<b>eat_msgs</b></a>() -&gt;
  104:    receive
  105:	Anything -&gt;
  106:	    eat_msgs()
  107:    after 0 -&gt;
  108:	    ok
  109:    end.
<a name="110"></a>  110:
<a name=operate>  111:<b>operate</b></a>(get,A,B) -&gt;
  112:    case random_key() of
  113:	1 -&gt;
  114:	    Class = random_class(),
  115:	    AnsA = lists:sort(dget_class(A,Class,all)),
  116:	    AnsB = lists:sort(dget_class(B,Class,all)),
  117:	    ?DEBUG(io:format("get_class ~w (~w)\n",[Class,AnsA])),
  118:	    AnsA = AnsB;
  119:	Other -&gt;
<a name="120"></a>  120:	    Class = random_class(),
  121:	    Key = random_key(),
  122:	    AnsA = dget(A,Class,Key),
  123:	    AnsB = dget(B,Class,Key),
  124:	    ?DEBUG(io:format("get ~w,~w (~w)\n",[Class,Key,AnsA])),
  125:	    AnsA = AnsB
  126:    end;
  127:
<a name=operate>  128:<b>operate</b></a>(put,A,B) -&gt;
  129:    Class = random_class(),
<a name="130"></a>  130:    Key = random_key(),
  131:    Value = random_value(),
  132:    AnsA = dput(A,Class,Key,Value),
  133:    AnsB = dput(B,Class,Key,Value),
  134:    ?DEBUG(io:format("put ~w,~w=~w (~w)\n",[Class,Key,Value,AnsA])),
  135:    AnsA = AnsB;
  136:
<a name=operate>  137:<b>operate</b></a>(erase,A,B) -&gt;
  138:    case random_key() of
  139:	1 -&gt;
<a name="140"></a>  140:	    Class = random_class(),
  141:	    AnsA = derase_class(A,Class),
  142:	    AnsB = derase_class(B,Class),
  143:	    ?DEBUG(io:format("erase_class ~w\n",[Class])),
  144:	    AnsA = AnsB;
  145:	Other -&gt;
  146:	    Class = random_class(),
  147:	    Key = random_key(),
  148:	    AnsA = derase(A,Class,Key),
  149:	    AnsB = derase(B,Class,Key),
<a name="150"></a>  150:	    ?DEBUG(io:format("erase ~w,~w (~w)\n",[Class,Key,AnsA])),
  151:	    AnsA = AnsB
  152:    end;
  153:
<a name=operate>  154:<b>operate</b></a>(dirty_get,A,B) -&gt;
  155:    Class = random_class(),
  156:    Key = random_key(),
  157:    %% only try dirty get on the b-side (which is never dumping)
  158:    AnsA = dget(A,Class,Key),
  159:    AnsB = dirty_dget(b,Class,Key),
<a name="160"></a>  160:    ?DEBUG(io:format("dirty_get ~w,~w (~w)\n",[Class,Key,AnsA])),
  161:    AnsA = AnsB;
  162:
<a name=operate>  163:<b>operate</b></a>(dump,A,B) -&gt;
  164:    case get(dump_ticket) of
  165:	{dump_more,Ticket} -&gt;
  166:	    Units = random_key(),
  167:	    NewTicket = ddump_next(A,Units,Ticket),
  168:	    put(dump_ticket,NewTicket),
  169:	    Result = 
<a name="170"></a>  170:		case NewTicket of
  171:		    done -&gt; done;
  172:		    _ -&gt;    dump_more
  173:		end,
  174:	    ?DEBUG(io:format("dump ~w (~w)\n",[Units,Result]));
  175:	_ -&gt;
  176:	    DumpDir = get(dump_dir),
  177:	    case random_key() of
  178:		1 -&gt;
  179:		    ?DEBUG(io:format("start_dump\n",[])),
<a name="180"></a>  180:		    NewTicket = ddump_first(A,DumpDir),
  181:		    put(dump_ticket,NewTicket);
  182:		2 -&gt;
  183:		    ?DEBUG(io:format("dump_and_restore\n",[])),
  184:		    {dump_more,NewTicket} = ddump_first(A,DumpDir),
  185:		    done = ddump_next(A,1000000,NewTicket),
  186:		    stop(A),
  187:		    {ok, NewA} = start(a,DumpDir),
  188:		    {new_a,NewA};
  189:		_ -&gt;
<a name="190"></a>  190:		    ?DEBUG(io:format("idle\n",[])),
  191:		    ok
  192:	    end
  193:    end.
  194:    
<a name=random_operation>  195:<b>random_operation</b></a>() -&gt;
  196:    Ops = {get,put,erase,dirty_get,dump},
  197:    random_element(Ops).
  198:
<a name=random_class>  199:<b>random_class</b></a>() -&gt;
<a name="200"></a>  200:    Classes = {foo,bar,tomat,gurka},
  201:    random_element(Classes).
  202:
<a name=random_key>  203:<b>random_key</b></a>() -&gt;
  204:    random:uniform(8).
  205:
<a name=random_value>  206:<b>random_value</b></a>() -&gt;
  207:    case random:uniform(5) of
  208:	1 -&gt; ok;
  209:	2 -&gt; {data,random_key()};
<a name="210"></a>  210:	3 -&gt; {foo,bar,random_class()};
  211:	4 -&gt; random:uniform(1000);
  212:	5 -&gt; {recursive,random_value()}
  213:    end.
  214:
<a name=random_element>  215:<b>random_element</b></a>(T) -&gt;
  216:    I = random:uniform(size(T)),
  217:    element(I,T).
  218:
  219:<i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="220"></a>  220:
<a name=show_table>  221:<b>show_table</b></a>(N) -&gt;
  222:    FileName = ["etsdump.",integer_to_list(N)],
  223:    case file:open(FileName,read) of
  224:	{ok,Fd} -&gt;
  225:	    show_entries(Fd);
  226:	_ -&gt;
  227:	    error
  228:    end.
  229:	    
<a name=show_entries><a name="230"></a>  230:<b>show_entries</b></a>(Fd) -&gt;
  231:    case phys_read_len(Fd) of
  232:	{ok,Len} -&gt;
  233:	    case phys_read_entry(Fd,Len) of
  234:		{ok,ok} -&gt;
  235:		    ok;
  236:		{ok,{Key,Val}} -&gt;
  237:		    io:format("~w\n",[{Key,Val}]),
  238:		    show_entries(Fd);
  239:		_ -&gt;
<a name="240"></a>  240:		    error
  241:	    end;
  242:	_ -&gt;
  243:	    error
  244:    end.
  245:
  246:<i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
  247:<i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
  248:<i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
  249:<i>%%% DEFINITIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="250"></a>  250:
  251:-<b>define</b>(NAMED_TABLES,true).
  252:-<b>define</b>(DB_NAME_KEY, {'$db_name'}).
  253:-<b>define</b>(LIST_OF_CLASSES_KEY,{'$list_of_classes'}).
  254:-<b>define</b>(DUMPING_FLAG_KEY,{'$dumping_flag'}).
  255:-<b>define</b>(DUMP_DIRECTORY_KEY,{'$dump_directory'}).
  256:-<b>define</b>(ERASE_MARK(Key),{{{'$erased'},Key}}).
  257:-<b>define</b>(ets_new,ets:new).
  258:-<b>define</b>(ets_lookup,ets:lookup).
  259:-<b>define</b>(ets_insert,ets:insert).    % erlang:db_put
<a name="260"></a>  260:-<b>define</b>(ets_delete,ets:delete).    % erlang:db_erase
  261:-<b>define</b>(ets_first,ets:first).      % erlang:db_first
  262:-<b>define</b>(ets_next,ets:next).        % erlang:db_next_key
  263:-<b>define</b>(ets_info,ets:info).        % erlang:db_info
  264:
  265:<i>%%% INTERFACE FUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
  266:
  267:<i>%%% start(DbName) -&gt; Pid | {error,Reason}</i>
  268:<i>%%%</i>
  269:<i>%%% Starts the ets table database with name DbName</i>
<a name="270"></a>  270:
<a name=start>  271:<b>start</b></a>(DbName) -&gt;
  272:    case gen_server:start_link(ets_tough_SUITE,{DbName,no_dump_dir},[]) of
  273:	{ok,Pid} when pid(Pid) -&gt;
  274:	    {ok, Pid};
  275:	Other -&gt;
  276:	    Other
  277:    end.
  278:
  279:<i>%%% start(DbName,DumpDir) -&gt; Pid | {error,Reason}</i>
<a name="280"></a>  280:<i>%%%</i>
  281:<i>%%% Starts the ets table database with name DbName, and reads a dump</i>
  282:<i>%%% from DumpDir when it starts.</i>
  283:
<a name=start>  284:<b>start</b></a>(DbName,DumpDir) -&gt;
  285:    case gen_server:start_link(ets_tough_SUITE,
  286:			       {DbName,{dump_dir,DumpDir}},[]) of
  287:	{ok,Pid} when pid(Pid) -&gt;
  288:	    {ok, Pid};
  289:	Other -&gt;
<a name="290"></a>  290:	    Other
  291:    end.
  292:
  293:<i>%%% stop(ServerPid) -&gt; {'EXIT',shutdown}</i>
  294:<i>%%%</i>
  295:<i>%%% Shuts down the ets table database</i>
  296:
<a name=stop>  297:<b>stop</b></a>(ServerPid) -&gt;
  298:    gen_server:call(ServerPid,stop).
  299:
<a name="300"></a>  300:<i>%%% dget(ServerPid,Class,Key) -&gt; {value,Value} | undefined</i>
  301:<i>%%%</i>
  302:<i>%%% Returns a value identified by Class,Key from the database, or</i>
  303:<i>%%% 'undefined' if there is no such value.</i>
  304:
<a name=dget>  305:<b>dget</b></a>(ServerPid,Class,Key) -&gt;
  306:    gen_server:call(ServerPid,{handle_lookup,Class,Key}).
  307:
  308:<i>%%% dirty_dget(DbName,Class,Key) -&gt; {value,Value} | undefined</i>
  309:<i>%%%</i>
<a name="310"></a>  310:<i>%%% This is looks up the value directly in the ets table</i>
  311:<i>%%% to avoid message passing. Several databases may be started,</i>
  312:<i>%%% so the admin table must be registered.</i>
  313:
<a name=dirty_dget>  314:<b>dirty_dget</b></a>(DbName,Class,Key) -&gt;
  315:    Admin = admin_table_name(DbName),
  316:    case catch(?ets_lookup(Admin,Class)) of
  317:	[{_Class,[Tab|_Tabs]}] -&gt;
  318:	    case ?ets_lookup(Tab,Key) of
  319:		[{_Key,Value}] -&gt;
<a name="320"></a>  320:		    {value,Value};
  321:		_ -&gt;
  322:		    undefined
  323:	    end;
  324:	_ -&gt;
  325:	    undefined
  326:    end.
  327:
  328:<i>%%% dput(ServerPid,Class,Key,Value) -&gt; undefined | {value,OldValue}</i>
  329:<i>%%%</i>
<a name="330"></a>  330:<i>%%% Inserts the given Value to be identified by Class,Key. Any prevoius</i>
  331:<i>%%% value is returned, or otherwise 'undefined'.</i>
  332:
<a name=dput>  333:<b>dput</b></a>(ServerPid,Class,Key,Value) -&gt;
  334:    gen_server:call(ServerPid,{handle_insert,Class,Key,Value}).
  335:
  336:<i>%%% derase(ServerPid,Class,Key) -&gt; undefined | {value,OldValue}</i>
  337:<i>%%%</i>
  338:<i>%%% Erases any value identified by Class,Key</i>
  339:
<a name=derase><a name="340"></a>  340:<b>derase</b></a>(ServerPid,Class,Key) -&gt;
  341:    gen_server:call(ServerPid,{handle_delete,Class,Key}).
  342:
  343:<i>%%% dget_class(ServerPid,Class,Condition) -&gt; KeyList</i>
  344:<i>%%%</i>
  345:<i>%%% Returns a list of keys where the instance match Condition.</i>
  346:<i>%%% Condition = 'all' returns all keys in the class.</i>
  347:<i>%%% The condition is supplied as Condition = {Mod, Fun, ExtraArgs},</i>
  348:<i>%%% where the instance will be prepended to ExtraArgs before each</i>
  349:<i>%%% call is made.</i>
<a name="350"></a>  350:
<a name=dget_class>  351:<b>dget_class</b></a>(ServerPid,Class,Condition) -&gt;
  352:    gen_server:call(ServerPid,
  353:		       {handle_get_class,Class,Condition},infinity).
  354:
  355:<i>%%% derase_class(ServerPid,Class) -&gt; ok</i>
  356:<i>%%%</i>
  357:<i>%%% Erases a whole class, identified by Class</i>
  358:
<a name=derase_class>  359:<b>derase_class</b></a>(ServerPid,Class) -&gt;
<a name="360"></a>  360:    gen_server:call(ServerPid,{handle_delete_class,Class}, infinity).
  361:
  362:<i>%%% dmodify(ServerPid,Application) -&gt; ok</i>
  363:<i>%%%</i>
  364:<i>%%% Applies a function on every instance in the database.</i>
  365:<i>%%% The user provided function must always return one of the</i>
  366:<i>%%% terms {ok,NewItem}, true, or false.</i>
  367:<i>%%% Aug 96, this is only used to reset all timestamp values</i>
  368:<i>%%% in the database.</i>
  369:<i>%%% The function is supplied as Application = {Mod, Fun, ExtraArgs},</i>
<a name="370"></a>  370:<i>%%% where the instance will be prepended to ExtraArgs before each</i>
  371:<i>%%% call is made.</i>
  372:
<a name=dmodify>  373:<b>dmodify</b></a>(ServerPid,Application) -&gt;
  374:    gen_server:call(ServerPid,{handle_dmodify,Application}, infinity).
  375:
  376:<i>%%% ddump_first(ServerPid,DumpDir) -&gt; {dump_more,Ticket} | already_dumping</i>
  377:<i>%%%</i>
  378:<i>%%% Starts dumping the database. This call redirects all database updates</i>
  379:<i>%%% to temporary tables, so that exactly the same database image will be</i>
<a name="380"></a>  380:<i>%%% written to disk as is in memory when this function is called.</i>
  381:<i>%%% The returned Ticket is to be used with ddump_next/2</i>
  382:
<a name=ddump_first>  383:<b>ddump_first</b></a>(ServerPid,DumpDir) -&gt;
  384:    gen_server:call(ServerPid,{handle_dump_first,DumpDir}, infinity).
  385:
  386:<i>%%% ddump_next(ServerPid,Count,Ticket) -&gt; {dump_more,Ticket} | done</i>
  387:<i>%%%</i>
  388:<i>%%% Dumps the database. This function performs Count units of dump work.</i>
  389:<i>%%% Higher value of Count makes the entire dump operation more efficient,</i>
<a name="390"></a>  390:<i>%%% but blocks the database for longer periods of time.</i>
  391:<i>%%% If there is still more work to be done, a new Ticket is returned,</i>
  392:<i>%%% or 'done' otherwise.</i>
  393:
<a name=ddump_next>  394:<b>ddump_next</b></a>(ServerPid,Count,Ticket) -&gt;
  395:    gen_server:call(ServerPid,{handle_dump_next,Ticket,Count},150000).
  396:
  397:<i>%%% PRIVATE HANDLER FUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
  398:
  399:<i>%%% Admin</i>
<a name="400"></a>  400:<i>%%% -----</i>
  401:<i>%%%</i>
  402:<i>%%% The database has a main administrative table Admin. It always contains</i>
  403:<i>%%% these four items:</i>
  404:<i>%%%</i>
  405:<i>%%%    {{'$db_name'},Name}</i>
  406:<i>%%%    {{'$list_of_classes'},ListOfClasses}</i>
  407:<i>%%%    {{'$dumping_flag'},BoolDumping}</i>
  408:<i>%%%    {{'$dump_directory'},Dir}</i>
  409:<i>%%%</i>
<a name="410"></a>  410:<i>%%% The ListOfClasses is simply a list of all Classes that has ever been</i>
  411:<i>%%% inserted in the database. It's used to know which tables to dump.</i>
  412:<i>%%% The dump flag is 'true' while dump is in progress, to make it</i>
  413:<i>%%% impossible to start a new dump before an old dump is completed.</i>
  414:<i>%%%</i>
  415:<i>%%% For each class there is an entry of the form</i>
  416:<i>%%%</i>
  417:<i>%%%    {Class,ListOfTables}</i>
  418:<i>%%%</i>
  419:<i>%%% Where the ListOfTables is the list of class tables (see below)</i>
<a name="420"></a>  420:<i>%%%</i>
  421:<i>%%% Class Tables</i>
  422:<i>%%% ------------</i>
  423:<i>%%%</i>
  424:<i>%%% The class tables are common ets tables that have the actual user</i>
  425:<i>%%% data stored in them.</i>
  426:<i>%%%</i>
  427:<i>%%% Normally there is only one class table, Mtab (main table).</i>
  428:<i>%%% When dumping is initiated, each class is syncronously given a </i>
  429:<i>%%% temporary table, Ttab, where all updates are stored. Reads are </i>
<a name="430"></a>  430:<i>%%% directed to the Ttab first, and only if not found there, Mtab is</i>
  431:<i>%%% consulted.</i>
  432:<i>%%%</i>
  433:<i>%%% Writes always go to the first table in the table sequence. This</i>
  434:<i>%%% ensures that the dump algorithm can enumerate the entries in the</i>
  435:<i>%%% other tables, without risk of being disrupted.</i>
  436:<i>%%%</i>
  437:<i>%%% When the dumping to disk is completed, it's time to write back</i>
  438:<i>%%% whatever updates that came into the Ttab to Mtab. To do this, a</i>
  439:<i>%%% third table is needed, Utab, to handle all updates while Ttab is</i>
<a name="440"></a>  440:<i>%%% being copied to Mtab. When all of Ttab is copied, Ttab is thrown</i>
  441:<i>%%% away, and the whole process is repeated with Utab as Ttab until</i>
  442:<i>%%% eventually nobody wrote to Utab while Ttab was copied (clean run).</i>
  443:<i>%%%</i>
  444:<i>%%% There is no _guarantee_ that this will ever happen, but unless there</i>
  445:<i>%%% is a constant (and quite high frequency) stream of updates to a</i>
  446:<i>%%% particular class, this should work.</i>
  447:<i>%%%</i>
  448:<i>%%% (It is possible to make this failsafe, by copying the elements in</i>
  449:<i>%%% Mtab to Ttab. This is probably a lot more expensive, though)</i>
<a name="450"></a>  450:<i>%%%</i>
  451:<i>%%% Erasure during dump</i>
  452:<i>%%% -------------------</i>
  453:<i>%%%</i>
  454:<i>%%% Erasing need special attention when a single class has several </i>
  455:<i>%%% tables. It really boils down to a number of cases:</i>
  456:<i>%%% </i>
  457:<i>%%% - element does not exist in Ttab.</i>
  458:<i>%%%     A special erase record is written, {{{'$erased'},Key}} which</i>
  459:<i>%%%     is hopefully different from all other keys used by the user.</i>
<a name="460"></a>  460:<i>%%% - element exists in Ttab</i>
  461:<i>%%%     The element is deleted, and erase record is written</i>
  462:<i>%%% - element does not exist in Ttab, but there is an erase record</i>
  463:<i>%%%     fine, do nothing</i>
  464:<i>%%% - element exist in Ttab, and there is an erase record</i>
  465:<i>%%%     This happens when a record is deleted from Ttab, then written</i>
  466:<i>%%%     back again. Erase records are not looked for when inserting</i>
  467:<i>%%%     new data (and that's not necessary)</i>
  468:<i>%%%</i>
  469:<i>%%% Then when Ttab should be copied to Mtab:</i>
<a name="470"></a>  470:<i>%%%</i>
  471:<i>%%% - found an element</i>
  472:<i>%%%     Usual case, just copy</i>
  473:<i>%%% - found erase record</i>
  474:<i>%%%     Check if there is an element with the same key as the erase</i>
  475:<i>%%%     record. If so it has been written later than the erasure, so</i>
  476:<i>%%%     the erasure is obsolete. Otherwise erase the record from Mtab.</i>
  477:<i>%%%</i>
  478:<i>%%% Delete Class</i>
  479:<i>%%% ------------</i>
<a name="480"></a>  480:<i>%%%</i>
  481:<i>%%% A slight problem is deleting an entire class while dumping is in</i>
  482:<i>%%% progress. For consitency, all user visible traces of the class must</i>
  483:<i>%%% be deleted, while dumping must not be affected. On top of that, the</i>
  484:<i>%%% deleted class may well be recreated while dumping is still going on,</i>
  485:<i>%%% and entries added.</i>
  486:<i>%%%</i>
  487:<i>%%% This is solved by having the dump algorithm keep track of the table</i>
  488:<i>%%% identifiers of the tables to dump, rather than asking the admin table</i>
  489:<i>%%% (since the class might be deleted there). The dump algorithm will</i>
<a name="490"></a>  490:<i>%%% itself take care of deleting the tables used in the dumping, while the</i>
  491:<i>%%% normal database interface deletes the "first table", the table that is</i>
  492:<i>%%% currently accepting all write operations.</i>
  493:
  494:
<a name=init>  495:<b>init</b></a>({DbName,DumpDir}) -&gt;
  496:    case DumpDir of
  497:	no_dump_dir -&gt;
  498:	    Admin = make_admin_table(DbName),
  499:	    ?ets_insert(Admin,{?LIST_OF_CLASSES_KEY,[]}),
<a name="500"></a>  500:	    init2(DbName,Admin);
  501:	{dump_dir,Dir} -&gt;
  502:	    case load_dump(DbName,Dir) of
  503:		{ok,Admin} -&gt;
  504:		    ?ets_insert(Admin,{?DUMP_DIRECTORY_KEY,Dir}),
  505:		    init2(DbName,Admin);
  506:		_ -&gt;
  507:		    cant_load_dump
  508:	    end
  509:    end.
<a name="510"></a>  510:
<a name=init2>  511:<b>init2</b></a>(DbName,Admin) -&gt;
  512:    ?ets_insert(Admin,{?DUMPING_FLAG_KEY,false}),
  513:    ?ets_insert(Admin,{?DB_NAME_KEY,DbName}),
  514:    {ok, Admin}.
  515:
<a name=terminate>  516:<b>terminate</b></a>(Reason,Admin) -&gt;
  517:    ok.
  518:
<a name=handle_call>  519:<b>handle_call</b></a>({handle_lookup,Class,Key},_From,Admin) -&gt;
<a name="520"></a>  520:    %% Lookup tables to search in
  521:    Reply =
  522:	case ?ets_lookup(Admin,Class) of
  523:	    [] -&gt;
  524:		undefined; %% no such class =&gt; no such record
  525:	    [{_,TabList}] -&gt;
  526:		{_,Ans} = table_lookup(TabList, Key),
  527:		Ans
  528:	end,
  529:    {reply,Reply,Admin};
<a name="530"></a>  530:
<a name=handle_call>  531:<b>handle_call</b></a>({handle_insert,Class,Key,Value},_From,Admin) -&gt;
  532:    %% Lookup in which table to write
  533:    Reply = 
  534:	case ?ets_lookup(Admin,Class) of
  535:	    [] -&gt;
  536:		%% undefined class, let's create it
  537:		Mtab = make_db_table(db_name(Admin),Class),
  538:		?ets_insert(Admin,{Class,[Mtab]}),
  539:		[{_,Classes}] = ?ets_lookup(Admin,?LIST_OF_CLASSES_KEY),
<a name="540"></a>  540:		?ets_insert(Admin,{?LIST_OF_CLASSES_KEY,[Class|Classes]}),
  541:		?ets_insert(Mtab, {Key, Value}),
  542:		undefined;
  543:	    [{_,[Tab|Tabs]}] -&gt;
  544:		{_,Old} = table_lookup([Tab|Tabs], Key),
  545:		?ets_insert(Tab, {Key, Value}),
  546:		Old
  547:	end,
  548:    {reply,Reply,Admin};
  549:
<a name=handle_call><a name="550"></a>  550:<b>handle_call</b></a>({handle_delete,Class,Key},_From,Admin) -&gt;
  551:    %% Lookup in which table to write
  552:    Reply =
  553:	case ?ets_lookup(Admin, Class) of
  554:	    [] -&gt;
  555:		undefined; %% no such class, but delete is happy anyway
  556:	    [{_,[Tab]}] -&gt;
  557:		%% When there is only one table, simply deleting is enough
  558:		{_,Old} = table_lookup(Tab,Key),
  559:		?ets_delete(Tab,Key),
<a name="560"></a>  560:		Old;
  561:	    [{_,[Tab|Tabs]}] -&gt;
  562:		%% When there are more tables, we have to write a delete
  563:		%% record into the first one, so that nobody goes looking
  564:		%% for this entry in some other table
  565:		{_,Old} = table_lookup([Tab|Tabs],Key),
  566:		?ets_insert(Tab, {?ERASE_MARK(Key), erased}),
  567:		?ets_delete(Tab,Key),
  568:		Old
  569:	end,
<a name="570"></a>  570:    {reply,Reply,Admin};
  571:
<a name=handle_call>  572:<b>handle_call</b></a>({handle_get_class,Class,Cond},_From,Admin) -&gt;
  573:    Reply =
  574:	case ?ets_lookup(Admin,Class) of     % Lookup tables to search in
  575:	    [] -&gt;
  576:		[];          % no such class
  577:	    [{_,TabList}] -&gt;
  578:		table_lookup_batch(TabList, Class, Cond)  % get class data
  579:	end,
<a name="580"></a>  580:    {reply,Reply,Admin};
  581:
<a name=handle_call>  582:<b>handle_call</b></a>({handle_delete_class,Class},_From,Admin) -&gt;
  583:    Reply =
  584:	case ?ets_lookup(Admin, Class) of
  585:	    [] -&gt;
  586:		ok;     % no such class, but delete_class is happy anyway
  587:	    [{_,[Tab|Tabs]}] -&gt;
  588:		%% Always delete the first table (the one we're writing into)
  589:		%% In case we're dumping, the rest of the tables will be
<a name="590"></a>  590:		%% taken care of by the dump algorithm.
  591:		?ets_delete(Tab),
  592:		[{_, Classes}] = ?ets_lookup(Admin, ?LIST_OF_CLASSES_KEY),
  593:		NewClasses = lists:delete(Class, Classes),
  594:		?ets_insert(Admin, {?LIST_OF_CLASSES_KEY, NewClasses}),
  595:		?ets_delete(Admin, Class),
  596:		ok
  597:	end,
  598:    {reply,Reply,Admin};
  599:
<a name=handle_call><a name="600"></a>  600:<b>handle_call</b></a>({handle_dmodify,Application},_From,Admin) -&gt;
  601:    [{_, Classes}] = ?ets_lookup(Admin, ?LIST_OF_CLASSES_KEY),
  602:    modify(Application, Classes, Admin),
  603:    {reply,ok,Admin};
  604:
<a name=handle_call>  605:<b>handle_call</b></a>({handle_dump_first,DumpDir},_From,Admin) -&gt;
  606:    case ?ets_lookup(Admin,?DUMPING_FLAG_KEY) of
  607:	[{_,true}] -&gt;
  608:	    {reply,already_dumping,Admin};
  609:	_ -&gt;
<a name="610"></a>  610:	    phys_remove_ok(DumpDir),
  611:	    [{_,Classes}] = ?ets_lookup(Admin,?LIST_OF_CLASSES_KEY),
  612:	    Tables = dump_prepare_classes(Classes,Admin),
  613:	    ?ets_insert(Admin,{?DUMPING_FLAG_KEY,true}),
  614:	    %% this is the new dir for dumping:
  615:	    ?ets_insert(Admin,{?DUMP_DIRECTORY_KEY,DumpDir}),
  616:	    handle_dump_next({[{admin,Classes}|Tables]},0,Admin)
  617:    end;
  618:
  619:<i>%% All done, good work!</i>
<a name=handle_call><a name="620"></a>  620:<b>handle_call</b></a>({handle_dump_next,Ticket,Count},_From,Admin) -&gt;
  621:    handle_dump_next(Ticket,Count,Admin);
  622:
<a name=handle_call>  623:<b>handle_call</b></a>(stop,_From,Admin) -&gt;
  624:    {stop, normal, ok, Admin}.
  625:
<a name=handle_info>  626:<b>handle_info</b></a>({'EXIT',Pid,Reason},Admin) -&gt;
  627:    {stop,normal,Admin}.
  628:
<a name=handle_delete>  629:<b>handle_delete</b></a>(Class, Key, Admin) -&gt;
<a name="630"></a>  630:    handle_call({handle_delete,Class,Key},from,Admin).
  631:
<a name=handle_insert>  632:<b>handle_insert</b></a>(Class, Key, Value, Admin) -&gt;
  633:    handle_call({handle_insert,Class,Key,Value},from,Admin).
  634:
<a name=handle_lookup>  635:<b>handle_lookup</b></a>(Class, Key, Admin) -&gt;
  636:    handle_call({handle_lookup,Class,Key},from,Admin).
  637:
  638:
<a name=handle_dump_next>  639:<b>handle_dump_next</b></a>({[]},_Count,Admin) -&gt;
<a name="640"></a>  640:    [{_Key,DumpDir}] = ?ets_lookup(Admin,?DUMP_DIRECTORY_KEY),
  641:    phys_ok_dump(DumpDir),
  642:    ?ets_insert(Admin,{?DUMPING_FLAG_KEY,false}),
  643:    {reply,done,Admin};
  644:
  645:<i>%% No more operations, return to user asking for more</i>
<a name=handle_dump_next>  646:<b>handle_dump_next</b></a>(Ticket,0,Admin) -&gt;
  647:    {reply,{dump_more,Ticket},Admin};
  648:
  649:<i>%% Dump the admin table. Costs one dump-work unit.</i>
<a name=handle_dump_next><a name="650"></a>  650:<b>handle_dump_next</b></a>({[{admin,Classes}|Tables]},Count,Admin) -&gt;
  651:    [{_Key,DumpDir}] = ?ets_lookup(Admin,?DUMP_DIRECTORY_KEY),
  652:    DumpData = phys_init_dump(admin,DumpDir,0),
  653:    phys_dump({?LIST_OF_CLASSES_KEY,Classes},DumpData),
  654:    phys_finish_dump(DumpData),
  655:    handle_dump_next({Tables},Count-1,Admin);
  656:
  657:<i>%% Pick out a class and start dumping it</i>
<a name=handle_dump_next>  658:<b>handle_dump_next</b></a>({[{Class,Mtab}|Tables]},Count,Admin) -&gt;
  659:    ?DEBUG(io:format("DUMP CLASS ~w\n",[Class])),
<a name="660"></a>  660:    [{_Key,DumpDir}] = ?ets_lookup(Admin,?DUMP_DIRECTORY_KEY),
  661:    DumpData = phys_init_dump(Class,DumpDir,length(Tables)+1),
  662:    First = ?ets_first(Mtab),
  663:    handle_dump_next({Class,Tables,Mtab,First,DumpData},Count,Admin);
  664:
  665:<i>%% All keys in this class have been written to disk, now we have to</i>
  666:<i>%% copy all items from temporary Ttab to main Mtab</i>
<a name=handle_dump_next>  667:<b>handle_dump_next</b></a>({Class,Tables,Stab,'$end_of_table',DumpData},Count,Admin) -&gt;
  668:    phys_finish_dump(DumpData),
  669:    ?DEBUG(io:format("Cleaning up temporary table in ~p\n",[Class])),
<a name="670"></a>  670:    case ?ets_lookup(Admin,Class) of
  671:	[{Key,[Utab,Mtab]}] -&gt;
  672:	    Ttab = make_db_table(db_name(Admin),Class),
  673:	    ?ets_insert(Admin,{Key,[Ttab,Utab,Mtab]}),
  674:	    First = ?ets_first(Utab),
  675:	    handle_dump_next({3,Class,Tables,Utab,First,Mtab},Count,Admin);
  676:	Other -&gt;
  677:	    %% Class deleted (and maybe recreated) while dumping, no need to 
  678:	    %% bring this one up to date. Just discard late additions.
  679:	    ?ets_delete(Stab),
<a name="680"></a>  680:	    handle_dump_next({Tables},Count,Admin)
  681:    end;
  682:
  683:<i>%% Dumping one key to disk. Costs one dump-work unit.</i>
<a name=handle_dump_next>  684:<b>handle_dump_next</b></a>({Class,Tables,Tab,Key,DumpData},Count,Admin) -&gt;
  685:    [KeyVal] = ?ets_lookup(Tab,Key),
  686:    phys_dump(KeyVal,DumpData),
  687:    NextKey = ?ets_next(Tab,Key),
  688:    handle_dump_next({Class,Tables,Tab,NextKey,DumpData},Count-1,Admin);
  689:
<a name="690"></a>  690:<i>%% Done copying elements from Ttab to Mtab</i>
  691:<i>%% check if Utab is empty and go on with next class, or</i>
  692:<i>%% make Utab the current Ttab, and run again</i>
  693:<i>%% ... will this ever end? ;-)</i>
<a name=handle_dump_next>  694:<b>handle_dump_next</b></a>({3,Class,Tables,Stab,'$end_of_table',Dtab},Count,Admin) -&gt;
  695:    case ?ets_lookup(Admin,Class) of
  696:	[{Key,[Ttab,Utab,Mtab]}] -&gt;
  697:	    case ?ets_info(Ttab,size) of
  698:		0 -&gt;
  699:		    ?ets_insert(Admin,{Key,[Mtab]}),
<a name="700"></a>  700:		    ?ets_delete(Ttab),
  701:		    ?ets_delete(Utab),
  702:		    handle_dump_next({Tables},Count,Admin);
  703:		Work -&gt;
  704:		    ?DEBUG(io:format("Switching direction in ~p\n",[Class])),
  705:		    %% Which is faster, deleting all the entries
  706:		    %% in a table, or deleting it and create a new?
  707:		    ?ets_delete(Utab),
  708:		    Ntab = make_db_table(db_name(Admin),Class),
  709:		    ?ets_insert(Admin,{Key,[Ntab,Ttab,Mtab]}),
<a name="710"></a>  710:		    First = ?ets_first(Ttab),
  711:		    handle_dump_next({3,Class,Tables,Ttab,First,Mtab},
  712:				     Count,Admin)
  713:	    end;
  714:	Other -&gt;
  715:	    %% Class deleted (and maybe recreated) while dumping, no need to 
  716:	    %% bring this one up to date. Just discard late additions.
  717:	    ?ets_delete(Stab),
  718:	    ?ets_delete(Dtab),
  719:	    handle_dump_next({Tables},Count,Admin)
<a name="720"></a>  720:    end;
  721:
  722:<i>%% Copy one key from Ttab to Mtab</i>
  723:<i>%% costs one dump-work unit</i>
<a name=handle_dump_next>  724:<b>handle_dump_next</b></a>({3,Class,Tables,Stab,Key,Dtab},Count,Admin) -&gt;
  725:    copy_dump_entry(Stab,Key,Dtab),
  726:    NextKey = ?ets_next(Stab,Key),
  727:    handle_dump_next({3,Class,Tables,Stab,NextKey,Dtab},Count-1,Admin).
  728:
  729:<i>%%% INTERNAL HELPER FUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="730"></a>  730:
  731:<i>%%% admin_table_name(DbName) -&gt; Name</i>
  732:<i>%%%</i>
  733:<i>%%% Returns the name of the admin table of the table DbName</i>
  734:
<a name=admin_table_name>  735:<b>admin_table_name</b></a>(DbName) -&gt;
  736:    Name = list_to_atom(lists:append(atom_to_list(DbName),"#admin")).
  737:
  738:<i>%%% make_admin_table(DbName) -&gt; EtsAdminTable</i>
  739:<i>%%%</i>
<a name="740"></a>  740:<i>%%% Creates and registers an ETS Admin table</i>
  741:
<a name=make_admin_table>  742:<b>make_admin_table</b></a>(DbName) -&gt;
  743:    ?ets_new(admin_table_name(DbName),[named_table,protected,db_type(DbName)]).
  744:
  745:<i>%%% make_db_table(DbName,Name) -&gt; EtsTable</i>
  746:<i>%%%</i>
  747:<i>%%% Creates an ETS database table</i>
  748:
<a name=make_db_table>  749:<b>make_db_table</b></a>(DbName, Name) -&gt;
<a name="750"></a>  750:    ?ets_new(Name,[protected,db_type(DbName)]).
  751:
<a name=db_name>  752:<b>db_name</b></a>(Admin) -&gt;
  753:    ets:lookup_element(Admin,?DB_NAME_KEY,2).
  754:
<a name=db_type>  755:<b>db_type</b></a>(DbName) -&gt;
  756:    case ets:lookup(?GLOBAL_PARAMS, DbName) of
  757:	[] -&gt;
  758:	    set;
  759:	[{DbName,X}] -&gt;
<a name="760"></a>  760:	    X
  761:    end.
  762:
  763:<i>%%% table_lookup(Table,Key) -&gt; </i>
  764:<i>%%% table_lookup(TableList,Key) -&gt;</i>
  765:<i>%%%    {def,{value,Value}} | {undef,undefined} | (erased,undefined}</i>
  766:<i>%%%</i>
  767:<i>%%% Looks up key in the table and returns it value, or undefined</i>
  768:<i>%%% if there is no such key.</i>
  769:<i>%%% If a list of tables is given, they are searched one after another</i>
<a name="770"></a>  770:<i>%%% for a matching key, until one is found. The search is discontinued</i>
  771:<i>%%% if a record telling that the key was deleted is found.</i>
  772:
<a name=table_lookup>  773:<b>table_lookup</b></a>([], Key) -&gt;
  774:    {undef,undefined};
<a name=table_lookup>  775:<b>table_lookup</b></a>([Table|Tables], Key) -&gt;
  776:    case table_lookup(Table,Key) of
  777:	{_,undefined} -&gt;
  778:	    case ?ets_lookup(Table,?ERASE_MARK(Key)) of
  779:		[] -&gt;
<a name="780"></a>  780:		    table_lookup(Tables,Key);
  781:		_Definition -&gt;
  782:		    %% The element has been deleted, don't look further!
  783:		    %% Pretend we never saw anything..
  784:		    {erased,undefined}
  785:	    end;
  786:	Answer -&gt;
  787:	    Answer
  788:    end;
<a name=table_lookup>  789:<b>table_lookup</b></a>(Table, Key) -&gt;
<a name="790"></a>  790:    case ?ets_lookup(Table,Key) of
  791:	[] -&gt;
  792:	    {undef,undefined};
  793:	[{_Key,Value}] -&gt;
  794:	    {def,{value,Value}}
  795:    end.
  796:
  797:<i>%%% table_lookup_batch(Tables, Class, Cond) -&gt; KeyList</i>
  798:<i>%%%</i>
  799:<i>%%% Extract the keys from a table or a table group.</i>
<a name="800"></a>  800:<i>%%% If a condition is supplied, it is on the form {Mod, Fun, ExtraArgs}</i>
  801:<i>%%% and returns {true,Key} or false when called using</i>
  802:<i>%%% apply(Mod, Fun, [Instance|ExtraArgs]).</i>
  803:<i>%%% Instance is, for historic reasons, {{Class, Key}, Value} when the function</i>
  804:<i>%%% is called. Cond = 'all' can be used to get all keys from a class.</i>
  805:
<a name=table_lookup_batch>  806:<b>table_lookup_batch</b></a>([],_Class,_Cond) -&gt;
  807:    [];
<a name=table_lookup_batch>  808:<b>table_lookup_batch</b></a>([Table|Tables],Class,Cond) -&gt;
  809:    table_lookup_batch([],Tables,Table,ets:first(Table),Class,Cond,[]).
<a name="810"></a>  810:    
<a name=table_lookup_batch>  811:<b>table_lookup_batch</b></a>(Passed,[],_,'$end_of_table',Class,Cond,Ack) -&gt;
  812:    Ack;
<a name=table_lookup_batch>  813:<b>table_lookup_batch</b></a>(Passed,[NewTable|Tables],Table,'$end_of_table',
  814:		   Class,Cond,Ack) -&gt;
  815:    table_lookup_batch(lists:append(Passed,[Table]),Tables,
  816:		       NewTable,ets:first(NewTable),Class,Cond,Ack);
<a name=table_lookup_batch>  817:<b>table_lookup_batch</b></a>(Passed,Tables,Table,?ERASE_MARK(Key),Class,Cond,Ack) -&gt;
  818:    table_lookup_batch(Passed,Tables,Table,?ets_next(Table,?ERASE_MARK(Key)),
  819:		       Class,Cond,Ack);
<a name="820"></a>  820:    
<a name=table_lookup_batch>  821:<b>table_lookup_batch</b></a>(Passed,Tables,Table,Key,Class,Cond,Ack) -&gt;
  822:    NewAck =
  823:	case table_lookup(Passed,Key) of
  824:	    {undef,undefined} -&gt;
  825:		[{_Key,Value}] = ?ets_lookup(Table,Key),
  826:		case Cond of    % are there any conditions?
  827:		    all -&gt;
  828:			[Key|Ack];
  829:		    {M, F, A} -&gt;
<a name="830"></a>  830:			%% apply the condition test.
  831:			%% Applications need keys to consist of
  832:			%% {class, primkey}, so we make it that way
  833:			case apply(M, F, [{{Class, Key}, Value}|A]) of
  834:			    {true, Key} -&gt; [Key|Ack];
  835:			    false -&gt;       Ack
  836:			end
  837:		end;
  838:	    Other -&gt; 
  839:		%% Already processed (or erased) key
<a name="840"></a>  840:		%% {def,{value,Value}} -&gt;
  841:		%% {erased,undefined} -&gt;
  842:		Ack
  843:	end,
  844:    table_lookup_batch(Passed,Tables,Table,?ets_next(Table,Key),
  845:		       Class,Cond,NewAck).
  846:
  847:<i>%%% modify(Application, ClassList, Admin) -&gt; ok.</i>
  848:<i>%%%</i>
  849:<i>%%% This function modifies each element of the classes</i>
<a name="850"></a>  850:
<a name=modify>  851:<b>modify</b></a>(Application, [], Admin) -&gt;
  852:    ok;
<a name=modify>  853:<b>modify</b></a>(Application, [Class|Classes], Admin) -&gt;
  854:    ?DEBUG(io:format("modifying class ~p\n", [Class])),
  855:    [{_,Tables}] = ?ets_lookup(Admin, Class),
  856:    modify_class(Application, Class, table_lookup_batch(Tables, Class, all),
  857:		 Admin),
  858:    modify(Application, Classes, Admin).
  859:
<a name=modify_class><a name="860"></a>  860:<b>modify_class</b></a>(Application, Class, [], Admin) -&gt;
  861:    ok;
<a name=modify_class>  862:<b>modify_class</b></a>({Mod, Fun, ExtraArgs}, Class, [Key|Keys], Admin) -&gt;
  863:    {ok, {{value, Value}, _Admin}} = handle_lookup(Class, Key, Admin),
  864:    %% The applications think that a key consists of {class, primkey},
  865:    %% so let them.
  866:    case apply(Mod,Fun,[{{Class, Key}, Value}|ExtraArgs]) of
  867:	{ok,{{NewClass, NewKey}, NewValue}} -&gt;   % The item is modified.
  868:	    %% remove old instance, insert new
  869:	    %% JALI could be optimized (we don't care about previous values),
<a name="870"></a>  870:	    %% but ets_delete/insert is *not* enough
  871:	    handle_delete(Class, Key, Admin),
  872:	    handle_insert(NewClass, NewKey, NewValue, Admin);
  873:	true -&gt;                           % The item should be left as it is.
  874:	    ok;
  875:	false -&gt;                          % The item should be removed!
  876:	    %% JALI could be optimized (we don't care about previous values),
  877:	    %% but ets_delete is *not* enough
  878:	    handle_delete(Class, Key, Admin)
  879:    end,
<a name="880"></a>  880:    modify_class({Mod, Fun, ExtraArgs}, Class, Keys, Admin).
  881:
  882:<i>%%% dump_prepare_classes(Classes,Admin) -&gt; ok</i>
  883:<i>%%%</i>
  884:<i>%%% Create a Ttab for each class, and insert </i>
  885:<i>%%% the new table order in Admin</i>
  886:
<a name=dump_prepare_classes>  887:<b>dump_prepare_classes</b></a>(Classes,Admin) -&gt;
  888:    ?DEBUG(io:format("DUMP CLASSES ~w\n",[Classes])),
  889:    dump_prepare_classes(Classes,Admin,[]).
<a name="890"></a>  890:
<a name=dump_prepare_classes>  891:<b>dump_prepare_classes</b></a>([],Admin,Ack) -&gt;
  892:    Ack;
<a name=dump_prepare_classes>  893:<b>dump_prepare_classes</b></a>([Class|Classes],Admin,Ack) -&gt;
  894:    [{_Class,[Mtab]}] = ?ets_lookup(Admin,Class),
  895:    %% Only one table =&gt; we can prepare for dumping
  896:    %% In case there are several tables defined, dumping is
  897:    %% already (still) in progress for this class (database inconsistent)
  898:    Ttab = make_db_table(db_name(Admin),Class),
  899:    ?ets_insert(Admin,{Class,[Ttab,Mtab]}),
<a name="900"></a>  900:    dump_prepare_classes(Classes,Admin,lists:append(Ack,[{Class,Mtab}])).
  901:
  902:<i>%%% copy_dump_entry(SourceTable,Key,DestinationTable) -&gt; NobodyCares</i>
  903:<i>%%%</i>
  904:<i>%%% Copies Key from SourceTable to DestinationTable.</i>
  905:<i>%%% If Key is an erase record, then the corresponding entry is deleted</i>
  906:<i>%%% from DestinationTable, if it should be (see Erasure during dump, above)</i>
  907:
<a name=copy_dump_entry>  908:<b>copy_dump_entry</b></a>(Stab,Key,Dtab) -&gt;
  909:    ?DEBUG(io:format("Copying key ~p\n",[Key])),
<a name="910"></a>  910:    case ?ets_lookup(Stab,Key) of
  911:	[{?ERASE_MARK(RealKey),_}] -&gt;
  912:	    %% Only erase if the entry RealKey hasn't been written again
  913:	    case ?ets_lookup(Stab,RealKey) of
  914:		[] -&gt;
  915:		    %% No, it hasn't: we should delete
  916:		    ?DEBUG(io:format("Erasing: ~p\n",[RealKey])),
  917:		    ?ets_delete(Dtab,RealKey);
  918:		Definition -&gt;
  919:		    %% It has, don't erase. In this case the new value
<a name="920"></a>  920:		    %% has already or will soon be written to Dtab
  921:		    ok
  922:	    end;
  923:	[KeyVal] -&gt;
  924:	    ?DEBUG(io:format("Forwarding: ~p\n",[KeyVal])),
  925:	    ?ets_insert(Dtab,KeyVal)
  926:    end.
  927:
  928:<i>%%% DUMP LOADING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
  929:
<a name=load_dump><a name="930"></a>  930:<b>load_dump</b></a>(DbName,DumpDir) -&gt;
  931:    case phys_load_dump_ok(DumpDir) of
  932:	ok -&gt;
  933:	    Admin = make_admin_table(DbName),
  934:	    ?ets_insert(Admin,{?DB_NAME_KEY,DbName}),
  935:	    case phys_load_table(DumpDir,0,Admin) of
  936:		ok -&gt;
  937:		    load_dump2(DumpDir,Admin);
  938:		Other -&gt;
  939:		    load_dump_failed(Admin,[]),
<a name="940"></a>  940:		    {error,{load_dump1,Other}}
  941:	    end;
  942:	Other -&gt;
  943:	    {error,{load_dump2,Other}}
  944:    end.
  945:
<a name=load_dump2>  946:<b>load_dump2</b></a>(DumpDir,Admin) -&gt;
  947:    case ?ets_lookup(Admin,?LIST_OF_CLASSES_KEY) of
  948:	[{_Key,Classes}] -&gt;
  949:	    case load_dump_tables(DumpDir,Admin,Classes) of
<a name="950"></a>  950:		ok -&gt;
  951:		    {ok, Admin};
  952:		Other -&gt;
  953:		    io:format("Dumping failed: ~p\n",[Other]),
  954:		    load_dump_failed(Admin,Classes)
  955:	    end;
  956:	Other -&gt;
  957:	    io:format("Dumping failed2: ~p\n",[Other]),
  958:	    load_dump_failed(Admin,[])
  959:    end.
<a name="960"></a>  960:
<a name=load_dump_failed>  961:<b>load_dump_failed</b></a>(Admin,[]) -&gt;
  962:    ?ets_delete(Admin),
  963:    {error,load_dump_failed};
<a name=load_dump_failed>  964:<b>load_dump_failed</b></a>(Admin,[Class|Classes]) -&gt;
  965:    case ?ets_lookup(Admin,Class) of
  966:	[{_Key,[Tab]}] -&gt;
  967:	    ?ets_delete(Tab);
  968:	_ -&gt;
  969:	    ok
<a name="970"></a>  970:    end,
  971:    load_dump_failed(Admin,Classes).
  972:
<a name=load_dump_tables>  973:<b>load_dump_tables</b></a>(DumpDir,Admin,[]) -&gt;
  974:    ok;
<a name=load_dump_tables>  975:<b>load_dump_tables</b></a>(DumpDir,Admin,[Class|Classes]) -&gt;
  976:    Mtab = make_db_table(db_name(Admin),Class),
  977:    ?ets_insert(Admin,{Class,[Mtab]}),
  978:    Num = length(Classes)+1,
  979:    case phys_load_table(DumpDir,Num,Mtab) of
<a name="980"></a>  980:	ok -&gt;
  981:	    load_dump_tables(DumpDir,Admin,Classes);
  982:	Other -&gt;
  983:	    {error,{load_dump_failed,Other}}
  984:    end.
  985:
  986:<i>%%% FILE ACCESS LAYER %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
  987:
  988:<i>%%% phys_init_dump(Class,DumpDir) -&gt; DumpData</i>
  989:
<a name=phys_init_dump><a name="990"></a>  990:<b>phys_init_dump</b></a>(Class,DumpDir,Num) -&gt;
  991:    ?DEBUG(io:format("Opened ~p for writing\n",[Class])),
  992:    FileName = [DumpDir,"/etsdump.",integer_to_list(Num)],
  993:    {tag1,{ok,Fd}} = {tag1,file:open(FileName,write)},
  994:    {Class,Fd}.
  995:
  996:<i>%%% phys_finish_dump(DumpData) -&gt; NobodyCares</i>
  997:
<a name=phys_finish_dump>  998:<b>phys_finish_dump</b></a>({Class,Fd}) -&gt;
  999:    ?DEBUG(io:format("Closed ~p\n",[Class])),
<a name="1000"></a> 1000:    phys_dump_term(Fd,ok),
 1001:    file:close(Fd), % JALI: OTP P1D returns true instead of ok, so no check
 1002:    ok.
 1003:
 1004:<i>%%% phys_dump(KeyVal,DumpData) -&gt; NobodyCares</i>
 1005:
<a name=phys_dump> 1006:<b>phys_dump</b></a>({Key,Val},{Class,Fd}) -&gt;
 1007:    ?DEBUG(io:format("To disk (~p.dump): {~p,~p}\n",[Class,Key,Val])),
 1008:    phys_dump_term(Fd,{Key,Val}),
 1009:    ok.
<a name="1010"></a> 1010:
<a name=phys_dump_term> 1011:<b>phys_dump_term</b></a>(Fd,Term) -&gt;
 1012:    Bin = binary_to_list(term_to_binary(Term)),
 1013:    {tag2,ok} = {tag2,io:put_chars(Fd,encode32(length(Bin)))},
 1014:    {tag3,ok} = {tag3,io:put_chars(Fd,Bin)}.
 1015:
 1016:<i>%%% phys_ok_dump(DumpDir) -&gt; NobodyCares</i>
 1017:
<a name=phys_ok_dump> 1018:<b>phys_ok_dump</b></a>(DumpDir) -&gt;
 1019:    ?DEBUG(io:format("Ok:ing dump dir ~s\n",[DumpDir])),
<a name="1020"></a> 1020:    FileName = [DumpDir,"/ok"],
 1021:    {tag4,{ok,Fd}} = {tag4,file:open(FileName,write)},
 1022:    {tag5,ok} = {tag5,io:format(Fd,"ok.\n",[])},
 1023:    file:close(Fd), % JALI: OTP P1D returns true instead of ok, so no check
 1024:    ok.
 1025:
<a name=phys_remove_ok> 1026:<b>phys_remove_ok</b></a>(DumpDir) -&gt;
 1027:    ?DEBUG(io:format("Removing any Ok in dump dir ~s\n",[DumpDir])),
 1028:    FileName = [DumpDir,"/ok"],
 1029:    %% don't care if delete returns ok, file probably doesn't exist
<a name="1030"></a> 1030:    file:delete(FileName),
 1031:    ok.
 1032:
<a name=phys_load_dump_ok> 1033:<b>phys_load_dump_ok</b></a>(DumpDir) -&gt;
 1034:    FileName = [DumpDir,"/ok"],
 1035:    case file:consult(FileName) of
 1036:	{ok,[ok]} -&gt;
 1037:	    ok;
 1038:	Other -&gt;
 1039:	    {error,{consult_error,Other}}
<a name="1040"></a> 1040:    end.
 1041:
<a name=phys_load_table> 1042:<b>phys_load_table</b></a>(DumpDir,N,Tab) -&gt;
 1043:    ?DEBUG(io:format("LOAD TABLE ~w\n",[N])),
 1044:    FileName = [DumpDir,"/etsdump.",integer_to_list(N)],
 1045:    case file:open(FileName,read) of
 1046:	{ok,Fd} -&gt;
 1047:	    phys_load_entries(Fd,Tab);
 1048:	Other -&gt;
 1049:	    {error,{open_error,Other}}
<a name="1050"></a> 1050:    end.
 1051:	    
<a name=phys_load_entries> 1052:<b>phys_load_entries</b></a>(Fd,Tab) -&gt;
 1053:    case phys_read_len(Fd) of
 1054:	{ok,Len} -&gt;
 1055:	    case phys_read_entry(Fd,Len) of
 1056:		{ok,ok} -&gt;
 1057:		    ok;
 1058:		{ok,{Key,Val}} -&gt;
 1059:		    ?ets_insert(Tab,{Key,Val}),
<a name="1060"></a> 1060:		    phys_load_entries(Fd,Tab);
 1061:		Other -&gt;
 1062:		    {error,{read_len,Other}}
 1063:	    end;
 1064:	Other -&gt;
 1065:	    {error,{read_len2,Other}}
 1066:    end.
 1067:
<a name=phys_read_len> 1068:<b>phys_read_len</b></a>(Fd) -&gt;
 1069:    case io:get_chars(Fd,'',4) of
<a name="1070"></a> 1070:	[A,B,C,D] -&gt;
 1071:	    {ok,decode32(A,B,C,D)};
 1072:	Other -&gt;
 1073:	    {error,{decode,Other}}
 1074:    end.
 1075:
<a name=phys_read_entry> 1076:<b>phys_read_entry</b></a>(Fd,Len) -&gt;
 1077:    case io:get_chars(Fd,'',Len) of
 1078:	L when list(L), length(L) == Len -&gt;
 1079:	    {ok,binary_to_term(list_to_binary(L))};
<a name="1080"></a> 1080:	Other -&gt;
 1081:	    {error,{read_term,Other}}
 1082:    end.
 1083:
<a name=encode32> 1084:<b>encode32</b></a>(N) -&gt;
 1085:    [(N bsr 24) band 255, 
 1086:     (N bsr 16) band 255, 
 1087:     (N bsr 8) band 255,
 1088:     N band 255].
 1089:
<a name=decode32><a name="1090"></a> 1090:<b>decode32</b></a>(A,B,C,D) -&gt;
 1091:    (A bsl 24) bor (B bsl 16) bor (C bsl 8) bor D.
 1092:
 1093:<i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
</pre>
<hr size=1><i>The transformation of this file (1094 lines) took 0.05 seconds</i><br>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head><title>/usr/home/jlouis/hacking/test_server/stdlib_test/gen_server_SUITE.erl</title></head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
    1:<i>%% The contents of this file are subject to the Erlang Public License,</i>
    2:<i>%% Version 1.1, (the "License"); you may not use this file except in</i>
    3:<i>%% compliance with the License. You should have received a copy of the</i>
    4:<i>%% Erlang Public License along with this software. If not, it can be</i>
    5:<i>%% retrieved via the world wide web at http://www.erlang.org/.</i>
    6:<i>%% </i>
    7:<i>%% Software distributed under the License is distributed on an "AS IS"</i>
    8:<i>%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See</i>
    9:<i>%% the License for the specific language governing rights and limitations</i>
<a name="10"></a>   10:<i>%% under the License.</i>
   11:<i>%% </i>
   12:<i>%% The Initial Developer of the Original Code is Ericsson Utvecklings AB.</i>
   13:<i>%% Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings</i>
   14:<i>%% AB. All Rights Reserved.</i>
   15:<i>%% </i>
   16:<i>%%</i>
   17:-<b>module</b>(gen_server_SUITE).
   18:
   19:-<b>include</b>("test_server.hrl").
<a name="20"></a>   20:-<b>include_lib</b>("kernel/include/inet.hrl").
   21:
   22:-<b>export</b>([init_per_testcase/2, fin_per_testcase/2]).
   23:
   24:-<b>export</b>([all/1]).
   25:-<b>export</b>([start/1, call/1, cast/1, cast_fast/1, info/1, abcast/1, multicall/1,
   26:	 multicall_down/1,
   27:	 call_remote1/1, call_remote2/1, call_remote3/1,
   28:	 call_remote_n1/1, call_remote_n2/1, call_remote_n3/1, spec_init/1,
   29:	 spec_init_local_registerd_parent/1, 
<a name="30"></a>   30:	 spec_init_global_registerd_parent/1
   31:	]).
   32:
   33:<i>% spawn export</i>
   34:-<b>export</b>([spec_init_local/2, spec_init_global/2, 
   35:	 spec_init_default_timeout/2, spec_init_anonymous/1,
   36:	 spec_init_anonymous_default_timeout/1,
   37:	 spec_init_not_proc_lib/1, cast_fast_messup/0]).
   38:
   39:
<a name="40"></a>   40:<i>% The gen_server behaviour</i>
   41:-<b>export</b>([init/1, handle_call/3, handle_cast/2,
   42:	 handle_info/2, terminate/2]).
   43:
<a name=all>   44:<b>all</b></a>(suite) -&gt; {req,[stdlib], [start, call, cast, cast_fast, info,
   45:	       abcast, multicall, multicall_down, call_remote1,
   46:	       call_remote2, call_remote3, call_remote_n1,
   47:	       call_remote_n2, call_remote_n3, spec_init,
   48:	       spec_init_local_registerd_parent,
   49:	       spec_init_global_registerd_parent]}.
<a name="50"></a>   50:
   51:-<b>define</b>(default_timeout, ?t:minutes(1)).
   52: 
<a name=init_per_testcase>   53:<b>init_per_testcase</b></a>(Case, Config) -&gt;
   54:    ?line Dog = ?t:timetrap(?default_timeout),
   55:    [{watchdog, Dog} | Config].
<a name=fin_per_testcase>   56:<b>fin_per_testcase</b></a>(Case, Config) -&gt;
   57:    Dog = ?config(watchdog, Config),
   58:    test_server:timetrap_cancel(Dog),
   59:    ok.
<a name="60"></a>   60:
   61:
   62:<i>%% --------------------------------------</i>
   63:<i>%% Start and stop a gen_server.</i>
   64:<i>%% --------------------------------------</i>
   65:
<a name=start>   66:<b>start</b></a>(suite) -&gt; [];
<a name=start>   67:<b>start</b></a>(Config) when list(Config) -&gt;
   68:    OldFl = process_flag(trap_exit, true),
   69:
<a name="70"></a>   70:    %% anonymous
   71:    ?line {ok, Pid0} = gen_server:start(gen_server_SUITE, [], []),
   72:    ?line ok = gen_server:call(Pid0, started_p),
   73:    ?line ok = gen_server:call(Pid0, stop),
   74:    ?line busy_wait_for_process(Pid0,600),
   75:    ?line {'EXIT', {noproc,_}} = (catch gen_server:call(Pid0, started_p, 1)),
   76:
   77:    %% anonymous with timeout
   78:    ?line {ok, Pid00} = gen_server:start(gen_server_SUITE, [],
   79:					 [{timeout,1000}]),
<a name="80"></a>   80:    ?line ok = gen_server:call(Pid00, started_p),
   81:    ?line ok = gen_server:call(Pid00, stop),
   82:    ?line {error, timeout} = gen_server:start(gen_server_SUITE, sleep,
   83:					      [{timeout,100}]),
   84:
   85:    %% anonymous with ignore
   86:    ?line ignore = gen_server:start(gen_server_SUITE, ignore, []),
   87:
   88:    %% anonymous with stop
   89:    ?line {error, stopped} = gen_server:start(gen_server_SUITE, stop, []),
<a name="90"></a>   90:
   91:    %% anonymous linked
   92:    ?line {ok, Pid1} =
   93:	gen_server:start_link(gen_server_SUITE, [], []),
   94:    ?line ok = gen_server:call(Pid1, started_p),
   95:    ?line ok = gen_server:call(Pid1, stop),
   96:    ?line receive
   97:	      {'EXIT', Pid1, stopped} -&gt;
   98:		  ok
   99:	  after 5000 -&gt;
<a name="100"></a>  100:		  test_server:fail(not_stopped)
  101:	  end,
  102:
  103:    %% local register
  104:    ?line {ok, Pid2} =
  105:	gen_server:start({local, my_test_name},
  106:			 gen_server_SUITE, [], []),
  107:    ?line ok = gen_server:call(my_test_name, started_p),
  108:    ?line {error, {already_started, Pid2}} =
  109:	gen_server:start({local, my_test_name},
<a name="110"></a>  110:			 gen_server_SUITE, [], []),
  111:    ?line ok = gen_server:call(my_test_name, stop),
  112:
  113:    ?line busy_wait_for_process(Pid2,600),
  114:
  115:    ?line {'EXIT', {noproc,_}} = (catch gen_server:call(Pid2, started_p, 10)),
  116:
  117:    %% local register linked
  118:    ?line {ok, Pid3} =
  119:	gen_server:start_link({local, my_test_name},
<a name="120"></a>  120:			      gen_server_SUITE, [], []), 
  121:    ?line ok = gen_server:call(my_test_name, started_p),
  122:    ?line {error, {already_started, Pid3}} =
  123:	gen_server:start({local, my_test_name},
  124:			 gen_server_SUITE, [], []),
  125:    ?line ok = gen_server:call(my_test_name, stop),
  126:    ?line receive
  127:	      {'EXIT', Pid3, stopped} -&gt;
  128:		  ok
  129:	  after 5000 -&gt;
<a name="130"></a>  130:		  test_server:fail(not_stopped)
  131:	  end,
  132:
  133:    %% global register
  134:    ?line {ok, Pid4} =
  135:	gen_server:start({global, my_test_name},
  136:			 gen_server_SUITE, [], []),
  137:    ?line ok = gen_server:call({global, my_test_name}, started_p),
  138:    ?line {error, {already_started, Pid4}} =
  139:	gen_server:start({global, my_test_name},
<a name="140"></a>  140:			 gen_server_SUITE, [], []),
  141:    ?line ok = gen_server:call({global, my_test_name}, stop),
  142:    test_server:sleep(1),
  143:    ?line {'EXIT', {noproc,_}} = (catch gen_server:call(Pid4, started_p, 10)),
  144:    %% global register linked
  145:    ?line {ok, Pid5} =
  146:	gen_server:start_link({global, my_test_name},
  147:			      gen_server_SUITE, [], []), 
  148:    ?line ok = gen_server:call({global, my_test_name}, started_p),
  149:    ?line {error, {already_started, Pid5}} =
<a name="150"></a>  150:	gen_server:start({global, my_test_name},
  151:			 gen_server_SUITE, [], []),
  152:    ?line ok = gen_server:call({global, my_test_name}, stop),
  153:    ?line receive
  154:	      {'EXIT', Pid5, stopped} -&gt;
  155:		  ok
  156:	  after 5000 -&gt;
  157:		  test_server:fail(not_stopped)
  158:	  end,
  159:
<a name="160"></a>  160:    test_server:messages_get(),
  161:
  162:    %% Must wait for all error messages before going to next test.
  163:    %% (otherwise it interferes too much with real time characteristics).
  164:    case os:type() of
  165:	vxworks -&gt;
  166:	    receive after 5000 -&gt; ok end;
  167:	_ -&gt;
  168:	    ok
  169:    end,
<a name="170"></a>  170:    process_flag(trap_exit, OldFl),
  171:    ok.
  172:
  173:<i>%% --------------------------------------</i>
  174:<i>%% Test gen_server:call and handle_call.</i>
  175:<i>%% Test all different return values from</i>
  176:<i>%% handle_call.</i>
  177:<i>%% --------------------------------------</i>
  178:
<a name=call>  179:<b>call</b></a>(suite) -&gt; [];
<a name=call><a name="180"></a>  180:<b>call</b></a>(Config) when list(Config) -&gt;
  181:    OldFl = process_flag(trap_exit, true),
  182:
  183:    ?line {ok, Pid} =
  184:	gen_server:start_link({local, my_test_name},
  185:			      gen_server_SUITE, [], []),
  186:
  187:    ?line ok = gen_server:call(my_test_name, started_p),
  188:    ?line delayed = gen_server:call(my_test_name, {delayed_answer,1}),
  189:
<a name="190"></a>  190:    %% two requests within a specified time.
  191:    ?line ok = gen_server:call(my_test_name, {call_within, 1000}),
  192:    test_server:sleep(500),
  193:    ?line ok = gen_server:call(my_test_name, next_call),
  194:    ?line ok = gen_server:call(my_test_name, {call_within, 1000}),
  195:    test_server:sleep(1500),
  196:    ?line false = gen_server:call(my_test_name, next_call),
  197:    
  198:    %% timeout call.
  199:    ?line delayed = gen_server:call(my_test_name, {delayed_answer,1}, 30),
<a name="200"></a>  200:    ?line {'EXIT',{timeout,_}} =
  201:	(catch gen_server:call(my_test_name, {delayed_answer,30}, 1)),
  202:
  203:    %% bad return value in the gen_server loop from handle_call.
  204:    ?line {'EXIT',{{bad_return_value, badreturn},_}} =
  205:	(catch gen_server:call(my_test_name, badreturn)),
  206:
  207:    process_flag(trap_exit, OldFl),
  208:    ok.
  209:
<a name="210"></a>  210:<i>%% --------------------------------------</i>
  211:<i>%% Test call to nonexisting processes on remote nodes</i>
  212:<i>%% --------------------------------------</i>
  213:
<a name=start_node>  214:<b>start_node</b></a>(Name) -&gt;
  215:    ?line Pa = filename:dirname(code:which(?MODULE)),
  216:    ?line N = test_server:start_node(Name, slave, [{args, " -pa " ++ Pa}]),
  217:    %% After starting a slave, it takes a little while until global knows
  218:    %% about it, even if nodes() includes it, so we make sure that global
  219:    %% knows about it before registering something on all nodes.
<a name="220"></a>  220:    global:sync(),
  221:    N.
  222:
<a name=call_remote1>  223:<b>call_remote1</b></a>(suite) -&gt; [];
<a name=call_remote1>  224:<b>call_remote1</b></a>(Config) when list(Config) -&gt;
  225:    ?line N = hubba,
  226:    ?line {ok, Node} = start_node(N),
  227:    ?line {ok, Pid} = rpc:call(Node, gen_server, start,
  228:			       [{global, N}, ?MODULE, [], []]),    
  229:    ?line ok = (catch gen_server:call({global, N}, started_p, infinity)),
<a name="230"></a>  230:    ?line exit(Pid, boom),
  231:    ?line {'EXIT', {noproc, _}} = (catch gen_server:call({global, N},
  232:							 started_p, infinity)),
  233:
  234:    ok.
  235:
<a name=call_remote2>  236:<b>call_remote2</b></a>(suite) -&gt; [];
<a name=call_remote2>  237:<b>call_remote2</b></a>(Config) when list(Config) -&gt;
  238:    ?line N = hubba,
  239:    ?line {ok, Node} = start_node(N),
<a name="240"></a>  240:
  241:    ?line {ok, Pid} = rpc:call(Node, gen_server, start,
  242:			       [{global, N}, ?MODULE, [], []]),
  243:    ?line ok = (catch gen_server:call(Pid, started_p, infinity)),
  244:    ?line exit(Pid, boom),
  245:    ?line {'EXIT', {noproc, _}} = (catch gen_server:call(Pid,
  246:							 started_p, infinity)),
  247:
  248:    ok.
  249:
<a name=call_remote3><a name="250"></a>  250:<b>call_remote3</b></a>(suite) -&gt; [];
<a name=call_remote3>  251:<b>call_remote3</b></a>(Config) when list(Config) -&gt;
  252:    ?line N = hubba,
  253:    ?line {ok, Node} = start_node(N),
  254:
  255:    ?line {ok, Pid} = rpc:call(Node, gen_server, start,
  256:			       [{local, piller}, ?MODULE, [], []]),
  257:    ?line ok = (catch gen_server:call({piller, Node}, started_p, infinity)),
  258:    ?line exit(Pid, boom),
  259:    ?line {'EXIT', {noproc, _}} = (catch gen_server:call({piller, Node},
<a name="260"></a>  260:							 started_p, infinity)),
  261:
  262:    ok.
  263:
  264:<i>%% --------------------------------------</i>
  265:<i>%% Test call to nonexisting node</i>
  266:<i>%% --------------------------------------</i>
  267:
<a name=call_remote_n1>  268:<b>call_remote_n1</b></a>(suite) -&gt; [];
<a name=call_remote_n1>  269:<b>call_remote_n1</b></a>(Config) when list(Config) -&gt;
<a name="270"></a>  270:    ?line N = hubba,
  271:    ?line {ok, Node} = start_node(N),
  272:    ?line {ok, Pid} = rpc:call(Node, gen_server, start,
  273:			       [{global, N}, ?MODULE, [], []]),
  274:    ?line R = test_server:stop_node(Node),
  275:    ?line {'EXIT', {noproc, _}} =
  276:	(catch gen_server:call({global, N}, started_p, infinity)),
  277:
  278:    ok.
  279:
<a name=call_remote_n2><a name="280"></a>  280:<b>call_remote_n2</b></a>(suite) -&gt; [];
<a name=call_remote_n2>  281:<b>call_remote_n2</b></a>(Config) when list(Config) -&gt;
  282:    ?line N = hubba,
  283:    ?line {ok, Node} = start_node(N),
  284:
  285:    ?line {ok, Pid} = rpc:call(Node, gen_server, start,
  286:			       [{global, N}, ?MODULE, [], []]),
  287:    ?line R = test_server:stop_node(Node),
  288:    ?line {'EXIT', {{nodedown, Node}, _}} = (catch gen_server:call(Pid,
  289:							 started_p, infinity)),
<a name="290"></a>  290:
  291:    ok.
  292:
<a name=call_remote_n3>  293:<b>call_remote_n3</b></a>(suite) -&gt; [];
<a name=call_remote_n3>  294:<b>call_remote_n3</b></a>(Config) when list(Config) -&gt;
  295:    ?line N = hubba,
  296:    ?line {ok, Node} = start_node(N),
  297:
  298:    ?line {ok, Pid} = rpc:call(Node, gen_server, start,
  299:			       [{local, piller}, ?MODULE, [], []]),
<a name="300"></a>  300:    ?line R = test_server:stop_node(Node),
  301:    ?line {'EXIT', {{nodedown, Node}, _}} = (catch gen_server:call({piller, Node},
  302:							 started_p, infinity)),
  303:
  304:    ok.
  305:
  306:<i>%% --------------------------------------</i>
  307:<i>%% Test gen_server:cast and handle_cast.</i>
  308:<i>%% Test all different return values from</i>
  309:<i>%% handle_cast.</i>
<a name="310"></a>  310:<i>%% --------------------------------------</i>
  311:
<a name=cast>  312:<b>cast</b></a>(suite) -&gt; [];
<a name=cast>  313:<b>cast</b></a>(Config) when list(Config) -&gt;
  314:    ?line {ok, Pid} =
  315:	gen_server:start({local, my_test_name},
  316:			 gen_server_SUITE, [], []),
  317:
  318:    ?line ok = gen_server:call(my_test_name, started_p),
  319:
<a name="320"></a>  320:    ?line ok = gen_server:cast(my_test_name, {self(),handle_cast}),
  321:    ?line receive
  322:	      {Pid, handled_cast} -&gt;
  323:		  ok
  324:	  after 1000 -&gt;
  325:		  test_server:fail(handle_cast)
  326:	  end,
  327:    
  328:    ?line ok = gen_server:cast(my_test_name, {self(),delayed_cast,1}),
  329:    ?line receive
<a name="330"></a>  330:	      {Pid, delayed} -&gt;
  331:		  ok
  332:	  after 1000 -&gt;
  333:		  test_server:fail(delayed_cast)
  334:	  end,
  335:    
  336:    ?line ok = gen_server:cast(my_test_name, {self(),stop}),
  337:    ?line receive
  338:	      {Pid, stopped} -&gt;
  339:		  ok
<a name="340"></a>  340:	  after 1000 -&gt;
  341:		  test_server:fail(stop)
  342:	  end,
  343:    ok.
  344:
<a name=cast_fast>  345:<b>cast_fast</b></a>(suite) -&gt; [];
<a name=cast_fast>  346:<b>cast_fast</b></a>(doc) -&gt; ["Test that cast really return immediately"];
<a name=cast_fast>  347:<b>cast_fast</b></a>(Config) when list(Config) -&gt;
  348:    ?line {ok,Node} = start_node(hubba),
  349:    ?line {_,"@"++Host} = lists:splitwith(fun ($@) -&gt; false; (_) -&gt; true end,
<a name="350"></a>  350:					   atom_to_list(Node)),
  351:    ?line FalseNode = list_to_atom("hopp@"++Host),
  352:    ?line true = rpc:cast(Node, ?MODULE, cast_fast_messup, []),
  353:<i>%    ?line io:format("Nodes ~p~n", [rpc:call(N, ?MODULE, cast_fast_messup, [])]),</i>
  354:    ?line test_server:sleep(1000),
  355:    ?line [Node] = nodes(),
  356:    ?line {Time,ok} = test_server:timecall(gen_server, cast, 
  357:					   [{hopp,FalseNode},hopp]),
  358:    ?line true = test_server:stop_node(Node),
  359:    ?line if Time &gt; 1.0 -&gt; % Default listen timeout is about 7.0 s
<a name="360"></a>  360:		  test_server:fail(hanging_cast);
  361:	     true -&gt; 
  362:		  ok
  363:	  end.
  364:
<a name=cast_fast_messup>  365:<b>cast_fast_messup</b></a>() -&gt;
  366:    %% Register a false node: hopp@hostname
  367:    unregister(erl_epmd),
  368:    erl_epmd:start_link(),
  369:    {ok,S} = gen_tcp:listen(0, []),
<a name="370"></a>  370:    {ok,P} = inet:port(S),
  371:    {ok,Creation} = erl_epmd:register_node(hopp, P),
  372:    receive after infinity -&gt; ok end.
  373:
  374:<i>%% --------------------------------------</i>
  375:<i>%% Test handle_info.</i>
  376:<i>%% --------------------------------------</i>
  377:
<a name=info>  378:<b>info</b></a>(suite) -&gt; [];
<a name=info>  379:<b>info</b></a>(Config) when list(Config) -&gt;
<a name="380"></a>  380:    ?line {ok, Pid} =
  381:	gen_server:start({local, my_test_name},
  382:			 gen_server_SUITE, [], []),
  383:
  384:    ?line ok = gen_server:call(my_test_name, started_p),
  385:
  386:    ?line Pid ! {self(),handle_info},
  387:    ?line receive
  388:	      {Pid, handled_info} -&gt;
  389:		  ok
<a name="390"></a>  390:	  after 1000 -&gt;
  391:		  test_server:fail(handle_info)
  392:	  end,
  393:    
  394:    ?line Pid ! {self(),delayed_info,1},
  395:    ?line receive
  396:	      {Pid, delayed_info} -&gt;
  397:		  ok
  398:	  after 1000 -&gt;
  399:		  test_server:fail(delayed_info)
<a name="400"></a>  400:	  end,
  401:    
  402:    ?line Pid ! {self(),stop},
  403:    ?line receive
  404:	      {Pid, stopped_info} -&gt;
  405:		  ok
  406:	  after 1000 -&gt;
  407:		  test_server:fail(stop_info)
  408:	  end,
  409:    ok.
<a name="410"></a>  410:
  411:<i>%% --------------------------------------</i>
  412:<i>%% Test gen_server:abcast and handle_cast.</i>
  413:<i>%% Test all different return values from</i>
  414:<i>%% handle_cast.</i>
  415:<i>%% --------------------------------------</i>
  416:
<a name=abcast>  417:<b>abcast</b></a>(suite) -&gt; [];
<a name=abcast>  418:<b>abcast</b></a>(Config) when list(Config) -&gt;
  419:    ?line {ok, Pid} =
<a name="420"></a>  420:	gen_server:start({local, my_test_name},
  421:			 gen_server_SUITE, [], []),
  422:
  423:    ?line ok = gen_server:call(my_test_name, started_p),
  424:
  425:    ?line abcast = gen_server:abcast(my_test_name, {self(),handle_cast}),
  426:    ?line receive
  427:	      {Pid, handled_cast} -&gt;
  428:		  ok
  429:	  after 1000 -&gt;
<a name="430"></a>  430:		  test_server:fail(abcast)
  431:	  end,
  432:    
  433:    ?line abcast = gen_server:abcast([node()], my_test_name,
  434:				     {self(),delayed_cast,1}),
  435:    ?line receive
  436:	      {Pid, delayed} -&gt;
  437:		  ok
  438:	  after 1000 -&gt;
  439:		  test_server:fail(delayed_abcast)
<a name="440"></a>  440:	  end,
  441:    
  442:    ?line abcast = gen_server:abcast(my_test_name, {self(),stop}),
  443:    ?line receive
  444:	      {Pid, stopped} -&gt;
  445:		  ok
  446:	  after 1000 -&gt;
  447:		  test_server:fail(abcast_stop)
  448:	  end,
  449:    ok.
<a name="450"></a>  450:
  451:<i>%% --------------------------------------</i>
  452:<i>%% Test gen_server:multicall and handle_call.</i>
  453:<i>%% Test all different return values from</i>
  454:<i>%% handle_call.</i>
  455:<i>%% --------------------------------------</i>
  456:
<a name=multicall>  457:<b>multicall</b></a>(suite) -&gt; [];
<a name=multicall>  458:<b>multicall</b></a>(Config) when list(Config) -&gt;
  459:    OldFl = process_flag(trap_exit, true),
<a name="460"></a>  460:
  461:    ?line {ok, Pid} =
  462:	gen_server:start_link({local, my_test_name},
  463:			      gen_server_SUITE, [], []),
  464:
  465:    ?line ok = gen_server:call(my_test_name, started_p),
  466:    Nodes = nodes(),
  467:    Node = node(),
  468:    ?line {[{Node,delayed}],Nodes} =
  469:	   gen_server:multi_call(my_test_name, {delayed_answer,1}),
<a name="470"></a>  470:
  471:    %% two requests within a specified time.
  472:    ?line {[{Node,ok}],[]} =
  473:	   gen_server:multi_call([Node], my_test_name, {call_within, 1000}),
  474:    test_server:sleep(500),
  475:    ?line {[{Node,ok}],[]} =
  476:	   gen_server:multi_call([Node], my_test_name, next_call),
  477:    ?line  {[{Node,ok}],[]} =
  478:	    gen_server:multi_call([Node], my_test_name, {call_within, 1000}),
  479:    test_server:sleep(1500),
<a name="480"></a>  480:    ?line {[{Node,false}],[]} =
  481:	   gen_server:multi_call([Node],my_test_name, next_call),
  482:
  483:    %% Stop the server.
  484:    ?line {[{Node,ok}],[]} =
  485:	   gen_server:multi_call([Node],my_test_name, stop),
  486:    receive
  487:	{'EXIT', Pid, stopped} -&gt; ok
  488:    after 1000 -&gt;
  489:	    test_server:fail(multicall_stop)
<a name="490"></a>  490:    end,
  491:    
  492:    process_flag(trap_exit, OldFl),
  493:
  494:    ok.
  495:
  496:<i>%% OTP-3587</i>
<a name=multicall_down>  497:<b>multicall_down</b></a>(suite) -&gt; [];
<a name=multicall_down>  498:<b>multicall_down</b></a>(Config) when list(Config) -&gt;
  499:    %% We need to find a named host which is inaccessible.
<a name="500"></a>  500:    ?line Name = case inaccessible_host() of
  501:		     {ok, Name0} -&gt;
  502:			 io:format("The inaccessible host is ~s~n", [Name0]),
  503:			 list_to_atom("node@" ++ Name0);
  504:		     notfound -&gt;
  505:			 test_server:fail({"couldn't run test - "
  506:					   "no inaccessible host found"})
  507:	  end,
  508:    %% We use 'global' as a gen_server to call.
  509:    ?line {Good, Bad} = gen_server:multi_call([Name, node()],
<a name="510"></a>  510:					      global_name_server,
  511:					      {whereis, gurkburk},
  512:					      3000),
  513:    io:format("good = ~p, bad = ~p~n", [Good, Bad]),
  514:    ?line [Name] = Bad,
  515:    ok.
  516:
<a name=inaccessible_host>  517:<b>inaccessible_host</b></a>() -&gt;
  518:    ?line {ok, Host} = inet:gethostname(),
  519:    ?line {ok, Hent} = inet:gethostbyname(Host),
<a name="520"></a>  520:    ?line #hostent{h_addr_list=[{A, B, C, D}|_]} = Hent,
  521:    ?line IP = check_ip(A, B, C, 1),
  522:    IP.
  523:
<a name=check_ip>  524:<b>check_ip</b></a>(A, B, C, D) when D == 255 -&gt;
  525:    notfound;
<a name=check_ip>  526:<b>check_ip</b></a>(A, B, C, D) -&gt;
  527:    IP = {A, B, C, D},
  528:    case inet:gethostbyaddr(IP) of
  529:	{ok, Ent} -&gt;
<a name="530"></a>  530:	    case gen_tcp:connect(IP, 45638, [], 2000) of
  531:		{error, timeout} -&gt;
  532:		    {ok, Ent#hostent.h_name};
  533:		_ -&gt;
  534:		    check_ip(A, B, C, D+1)
  535:	    end;
  536:	{error, _} -&gt;
  537:	    check_ip(A, B, C, D+1)
  538:    end.
  539:
<a name=busy_wait_for_process><a name="540"></a>  540:<b>busy_wait_for_process</b></a>(Pid,N) -&gt;
  541:    case erlang:is_process_alive(Pid) of
  542:	true -&gt;
  543:	    receive
  544:	    after 100 -&gt;
  545:		    ok
  546:	    end,
  547:	    busy_wait_for_process(Pid,N-1);
  548:	_ -&gt;
  549:	    ok
<a name="550"></a>  550:    end.
  551:<i>%%--------------------------------------------------------------</i>
<a name=spec_init>  552:<b>spec_init</b></a>(doc) -&gt;
  553:    ["Test gen_server:enter_loop/[3,4,5]. Used when you want to write " 
  554:     "your own special init-phase."];
<a name=spec_init>  555:<b>spec_init</b></a>(suite) -&gt;
  556:    [];
<a name=spec_init>  557:<b>spec_init</b></a>(Config) when list(Config) -&gt;
  558:    
  559:    process_flag(trap_exit, true),
<a name="560"></a>  560:    
  561:    ?line {ok, Pid0} = start_link(spec_init_local, [{ok, my_server}, []]),
  562:    ?line ok = gen_server:call(Pid0, started_p),
  563:    ?line ok = gen_server:call(Pid0, stop),
  564:    receive 
  565:	{'EXIT', Pid0, stopped} -&gt;
  566: 	    ok
  567:    after 5000 -&gt;
  568:	    test_server:fail(gen_server_did_not_die)
  569:    end,
<a name="570"></a>  570:    
  571:    ?line {ok, Pid01} = start_link(spec_init_local, [{not_ok, my_server}, []]),
  572:    receive 
  573: 	{'EXIT', Pid01, process_not_registered} -&gt;
  574: 	    ok
  575:    after 5000 -&gt;
  576:	    test_server:fail(gen_server_did_not_die)
  577:    end,
  578:    
  579:    ?line {ok, Pid1} = start_link(spec_init_global, [{ok, my_server}, []]),
<a name="580"></a>  580:    ?line ok = gen_server:call(Pid1, started_p),
  581:    ?line ok = gen_server:call(Pid1, stop),
  582:    receive 
  583:	{'EXIT', Pid1, stopped} -&gt;
  584: 	    ok
  585:    after 5000 -&gt;
  586:	    test_server:fail(gen_server_did_not_die)
  587:    end,
  588:    
  589:    ?line {ok, Pid11} = 
<a name="590"></a>  590:	start_link(spec_init_global, [{not_ok, my_server}, []]),
  591:
  592:    receive 
  593:	{'EXIT', Pid11, process_not_registered_globally} -&gt;
  594: 	    ok
  595:    after 5000 -&gt;
  596:	    test_server:fail(gen_server_did_not_die)
  597:    end,
  598:    
  599:    ?line {ok, Pid2} = start_link(spec_init_anonymous, [[]]),
<a name="600"></a>  600:    ?line ok = gen_server:call(Pid2, started_p),
  601:    ?line ok = gen_server:call(Pid2, stop),
  602:    receive 
  603:	{'EXIT', Pid2, stopped} -&gt;
  604: 	    ok
  605:    after 5000 -&gt;
  606:	    test_server:fail(gen_server_did_not_die)
  607:    end,
  608:    
  609:    ?line {ok, Pid3} = start_link(spec_init_anonymous_default_timeout, [[]]),
<a name="610"></a>  610:    ?line ok = gen_server:call(Pid3, started_p),
  611:    ?line ok = gen_server:call(Pid3, stop),
  612:    receive 
  613:	{'EXIT', Pid3, stopped} -&gt;
  614: 	    ok
  615:    after 5000 -&gt;
  616:	    test_server:fail(gen_server_did_not_die)
  617:    end,
  618:    
  619:    ?line {ok, Pid4} = 
<a name="620"></a>  620:	start_link(spec_init_default_timeout, [{ok, my_server}, []]),
  621:    ?line ok = gen_server:call(Pid4, started_p),
  622:    ?line ok = gen_server:call(Pid4, stop),
  623:    receive 
  624:	{'EXIT', Pid4, stopped} -&gt;
  625: 	    ok
  626:    after 5000 -&gt;
  627:	    test_server:fail(gen_server_did_not_die)
  628:    end,
  629:
<a name="630"></a>  630:    ?line Pid5 = 
  631:	erlang:spawn_link(?MODULE, spec_init_not_proc_lib, [[]]),
  632:    receive 
  633:	{'EXIT', Pid5, process_was_not_started_by_proc_lib} -&gt;
  634: 	    ok
  635:    after 5000 -&gt;
  636:	    test_server:fail(gen_server_did_not_die)
  637:    end,
  638:    ok.
  639:
<a name="640"></a>  640:<i>%%--------------------------------------------------------------</i>
<a name=spec_init_local_registerd_parent>  641:<b>spec_init_local_registerd_parent</b></a>(doc) -&gt;
  642:    ["Test that terminate is run when the parent is a locale registered "
  643:     "process OTP-4820"];
<a name=spec_init_local_registerd_parent>  644:<b>spec_init_local_registerd_parent</b></a>(suite) -&gt; [];
<a name=spec_init_local_registerd_parent>  645:<b>spec_init_local_registerd_parent</b></a>(Config) when list(Config) -&gt;
  646:
  647:    register(foobar, self()),
  648:    process_flag(trap_exit, true),
  649:    
<a name="650"></a>  650:    ?line {ok, Pid} = start_link(spec_init_local, [{ok, my_server}, []]),
  651:    
  652:    ?line ok = gen_server:cast(my_server, {self(),stop}),
  653:    ?line receive
  654:	      {Pid, stopped} -&gt;
  655:		  ok
  656:	  after 1000 -&gt;
  657:		  test_server:fail(stop)
  658:	  end,
  659:    unregister(foobar),
<a name="660"></a>  660:    ok.
  661:<i>%%--------------------------------------------------------------</i>
<a name=spec_init_global_registerd_parent>  662:<b>spec_init_global_registerd_parent</b></a>(doc) -&gt;
  663:    ["Test that terminate is run when the parent is a global registered "
  664:     "process OTP-4820"];
<a name=spec_init_global_registerd_parent>  665:<b>spec_init_global_registerd_parent</b></a>(suite) -&gt; [];
<a name=spec_init_global_registerd_parent>  666:<b>spec_init_global_registerd_parent</b></a>(Config) when list(Config) -&gt;
  667:
  668:    global:register_name(foobar, self()),
  669:    process_flag(trap_exit, true),
<a name="670"></a>  670:    
  671:    ?line {ok, Pid} = start_link(spec_init_global, [{ok, my_server}, []]),
  672:    
  673:    ?line ok = gen_server:call(Pid, started_p),
  674:    ?line ok = gen_server:cast(Pid, {self(),stop}),  
  675:
  676:    ?line receive
  677:	      {Pid, stopped} -&gt;
  678:		  ok
  679:	  after 1000 -&gt;
<a name="680"></a>  680:		  test_server:fail(stop)
  681:	  end,
  682:    global:unregister_name(foobar),
  683:    ok.
  684:<i>%%--------------------------------------------------------------</i>
  685:<i>%% Help functions to spec_init_*</i>
<a name=start_link>  686:<b>start_link</b></a>(Init, Options) -&gt;
  687:    proc_lib:start_link(?MODULE, Init, Options).
  688:
<a name=spec_init_local>  689:<b>spec_init_local</b></a>({ok, Name}, Options) -&gt;
<a name="690"></a>  690:    process_flag(trap_exit, true),
  691:    register(Name, self()),
  692:    proc_lib:init_ack({ok, self()}),
  693:    %% Supervised init can occur here  ...
  694:    gen_server:enter_loop(?MODULE, Options, {}, {local, Name}, infinity);
  695:
<a name=spec_init_local>  696:<b>spec_init_local</b></a>({not_ok, Name}, Options) -&gt;
  697:    process_flag(trap_exit, true),
  698:    proc_lib:init_ack({ok, self()}),
  699:    %% Supervised init can occur here  ...
<a name="700"></a>  700:    gen_server:enter_loop(?MODULE, Options, {}, {local, Name}, infinity).
  701:
<a name=spec_init_global>  702:<b>spec_init_global</b></a>({ok, Name}, Options) -&gt;
  703:    process_flag(trap_exit, true),
  704:    global:register_name(Name, self()),
  705:    proc_lib:init_ack({ok, self()}),
  706:    %% Supervised init can occur here  ...
  707:    gen_server:enter_loop(?MODULE, Options, {}, {global, Name}, infinity);
  708:
<a name=spec_init_global>  709:<b>spec_init_global</b></a>({not_ok, Name}, Options) -&gt;
<a name="710"></a>  710:    process_flag(trap_exit, true),
  711:    proc_lib:init_ack({ok, self()}),
  712:    %% Supervised init can occur here  ...
  713:    gen_server:enter_loop(?MODULE, Options, {}, {global, Name}, infinity).
  714:
<a name=spec_init_default_timeout>  715:<b>spec_init_default_timeout</b></a>({ok, Name}, Options) -&gt; 
  716:    process_flag(trap_exit, true),
  717:    register(Name, self()),
  718:    proc_lib:init_ack({ok, self()}),
  719:    %% Supervised init can occur here  ...
<a name="720"></a>  720:    gen_server:enter_loop(?MODULE, Options, {}, {local, Name}).
  721:
<a name=spec_init_anonymous>  722:<b>spec_init_anonymous</b></a>(Options) -&gt;
  723:    process_flag(trap_exit, true),
  724:    proc_lib:init_ack({ok, self()}),
  725:    %% Supervised init can occur here  ...
  726:    gen_server:enter_loop(?MODULE, Options, {}, infinity).
  727:
<a name=spec_init_anonymous_default_timeout>  728:<b>spec_init_anonymous_default_timeout</b></a>(Options) -&gt;
  729:    process_flag(trap_exit, true),
<a name="730"></a>  730:    proc_lib:init_ack({ok, self()}),
  731:    %% Supervised init can occur here  ...
  732:    gen_server:enter_loop(?MODULE, Options, {}).
  733:
<a name=spec_init_not_proc_lib>  734:<b>spec_init_not_proc_lib</b></a>(Options) -&gt;
  735:    gen_server:enter_loop(?MODULE, Options, {}, infinity).
  736:
  737:<i>%%% --------------------------------------------------------</i>
  738:<i>%%% Here is the tested gen_server behaviour.</i>
  739:<i>%%% --------------------------------------------------------</i>
<a name="740"></a>  740:
<a name=init>  741:<b>init</b></a>([]) -&gt;
  742:    {ok, []};
<a name=init>  743:<b>init</b></a>(ignore) -&gt;
  744:    ignore;
<a name=init>  745:<b>init</b></a>(stop) -&gt;
  746:    {stop, stopped};
<a name=init>  747:<b>init</b></a>(sleep) -&gt;
  748:    test_server:sleep(1000),
  749:    {ok, []}.
<a name="750"></a>  750:
<a name=handle_call>  751:<b>handle_call</b></a>(started_p, From, State) -&gt;
  752:    io:format("FROZ"),
  753:    {reply,ok,State};
<a name=handle_call>  754:<b>handle_call</b></a>({delayed_answer, T}, From, State) -&gt;
  755:    {noreply,{reply_to,From},T};
<a name=handle_call>  756:<b>handle_call</b></a>({call_within, T}, From, _) -&gt;
  757:    {reply,ok,call_within,T};
<a name=handle_call>  758:<b>handle_call</b></a>(next_call, From, call_within) -&gt;
  759:    {reply,ok,[]};
<a name=handle_call><a name="760"></a>  760:<b>handle_call</b></a>(next_call, From, State) -&gt;
  761:    {reply,false,State};
<a name=handle_call>  762:<b>handle_call</b></a>(badreturn, From, State) -&gt;
  763:    badreturn;
<a name=handle_call>  764:<b>handle_call</b></a>(stop, From, State) -&gt;
  765:    {stop,stopped,ok,State}.
  766:
<a name=handle_cast>  767:<b>handle_cast</b></a>({From,handle_cast}, State) -&gt;
  768:    From ! {self(), handled_cast},
  769:    {noreply, State};
<a name=handle_cast><a name="770"></a>  770:<b>handle_cast</b></a>({From,delayed_cast,T}, State) -&gt;
  771:    {noreply, {delayed_cast,From}, T};
<a name=handle_cast>  772:<b>handle_cast</b></a>({From, stop}, State) -&gt;
  773:    io:format("BAZ"),
  774:    {stop, {From,stopped}, State}.
  775:
<a name=handle_info>  776:<b>handle_info</b></a>(timeout, {reply_to, From}) -&gt;
  777:    gen_server:reply(From, delayed),
  778:    {noreply, []};
<a name=handle_info>  779:<b>handle_info</b></a>(timeout, call_within) -&gt;
<a name="780"></a>  780:    {noreply, []};
<a name=handle_info>  781:<b>handle_info</b></a>(timeout, {delayed_cast, From}) -&gt;
  782:    From ! {self(), delayed},
  783:    {noreply, []};
<a name=handle_info>  784:<b>handle_info</b></a>(timeout, {delayed_info, From}) -&gt;
  785:    From ! {self(), delayed_info},
  786:    {noreply, []};
<a name=handle_info>  787:<b>handle_info</b></a>({From, handle_info}, State) -&gt;
  788:    From ! {self(), handled_info},
  789:    {noreply, []};
<a name=handle_info><a name="790"></a>  790:<b>handle_info</b></a>({From, delayed_info, T}, State) -&gt;
  791:    {noreply, {delayed_info, From}, T};
<a name=handle_info>  792:<b>handle_info</b></a>({From, stop}, State) -&gt;
  793:    {stop, {From,stopped_info}, State};
<a name=handle_info>  794:<b>handle_info</b></a>(Info, State) -&gt;
  795:    {noreply, State}.
  796:
<a name=terminate>  797:<b>terminate</b></a>({From, stopped}, State) -&gt;
  798:    io:format("FOOBAR"),
  799:    From ! {self(), stopped},
<a name="800"></a>  800:    ok;
<a name=terminate>  801:<b>terminate</b></a>({From, stopped_info}, State) -&gt;
  802:    From ! {self(), stopped_info},
  803:    ok;
<a name=terminate>  804:<b>terminate</b></a>(Reason, State) -&gt;
  805:    ok.
  806:
  807:
</pre>
<hr size=1><i>The transformation of this file (808 lines) took 0.02 seconds</i><br>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head><title>/usr/home/jlouis/hacking/test_server/stdlib_test/erl_eval_SUITE.erl</title></head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
    1:<i>%% ``The contents of this file are subject to the Erlang Public License,</i>
    2:<i>%% Version 1.1, (the "License"); you may not use this file except in</i>
    3:<i>%% compliance with the License. You should have received a copy of the</i>
    4:<i>%% Erlang Public License along with this software. If not, it can be</i>
    5:<i>%% retrieved via the world wide web at http://www.erlang.org/.</i>
    6:<i>%% </i>
    7:<i>%% Software distributed under the License is distributed on an "AS IS"</i>
    8:<i>%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See</i>
    9:<i>%% the License for the specific language governing rights and limitations</i>
<a name="10"></a>   10:<i>%% under the License.</i>
   11:<i>%% </i>
   12:<i>%% The Initial Developer of the Original Code is Ericsson Utvecklings AB.</i>
   13:<i>%% Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings</i>
   14:<i>%% AB. All Rights Reserved.''</i>
   15:<i>%% </i>
   16:<i>%%     $Id$</i>
   17:<i>%%</i>
   18:-<b>module</b>(erl_eval_SUITE).
   19:-<b>export</b>([all/1]).
<a name="20"></a>   20:
   21:-<b>export</b>([guard_1/1, guard_2/1,
   22:	 match_pattern/1,
   23:	 match_bin/1,
   24:	 string_plusplus/1,
   25:	 pattern_expr/1,
   26:         guard_3/1,
   27:         lc/1,
   28:         simple_cases/1,
   29:         funs/1]).
<a name="30"></a>   30:
   31:<i>%%</i>
   32:<i>%% Define to run outside of test server</i>
   33:<i>%%</i>
   34:<i>%%-define(STANDALONE,1).</i>
   35:
   36:-<b>import</b>(lists,[concat/1, sort/1]).
   37:
   38:-<b>export</b>([count_down/2, count_down_fun/0, do_apply/2, 
   39:         local_func/3, local_func_value/2]).
<a name="40"></a>   40:
   41:-<b>ifdef</b>(STANDALONE).
   42:-<b>define</b>(config(A,B),config(A,B)).
   43:-<b>export</b>([config/2]).
   44:-<b>define</b>(line, noop, ).
<a name=config>   45:<b>config</b></a>(priv_dir,_) -&gt;
   46:    ".".
   47:-<b>else</b>.
   48:-<b>include</b>("test_server.hrl").
   49:-<b>export</b>([init_per_testcase/2, fin_per_testcase/2]).
<a name="50"></a>   50:<i>% Default timetrap timeout (set in init_per_testcase).</i>
   51:-<b>define</b>(default_timeout, ?t:minutes(1)).
<a name=init_per_testcase>   52:<b>init_per_testcase</b></a>(_Case, Config) -&gt;
   53:    ?line Dog = ?t:timetrap(?default_timeout),
   54:    [{watchdog, Dog} | Config].
<a name=fin_per_testcase>   55:<b>fin_per_testcase</b></a>(_Case, Config) -&gt;
   56:    Dog = ?config(watchdog, Config),
   57:    test_server:timetrap_cancel(Dog),
   58:    ok.
   59:-<b>endif</b>.
<a name="60"></a>   60:
<a name=all>   61:<b>all</b></a>(doc) -&gt;
   62:    ["Test cases for the 'erl_eval' module."];
<a name=all>   63:<b>all</b></a>(suite) -&gt;
   64:    [guard_1, guard_2, match_pattern, string_plusplus, pattern_expr,
   65:     match_bin, guard_3, lc, simple_cases, funs].
   66:
<a name=guard_1>   67:<b>guard_1</b></a>(doc) -&gt;
   68:    ["(OTP-2405)"];
<a name=guard_1>   69:<b>guard_1</b></a>(suite) -&gt;
<a name="70"></a>   70:    [];
<a name=guard_1>   71:<b>guard_1</b></a>(Config) when list(Config) -&gt;
   72:    ?line {ok,Tokens ,_} =
   73:	erl_scan:string("if a+4 == 4 -&gt; yes; true -&gt; no end. "),
   74:    ?line {ok, [Expr]} = erl_parse:parse_exprs(Tokens),
   75:    ?line no = guard_1_compiled(),
   76:    ?line {value, no, []} = erl_eval:expr(Expr, []),
   77:    ok.
   78:
<a name=guard_1_compiled>   79:<b>guard_1_compiled</b></a>() -&gt;
<a name="80"></a>   80:    if a+4 == 4 -&gt; yes; true -&gt; no end.
   81:
<a name=guard_2>   82:<b>guard_2</b></a>(doc) -&gt;
   83:    ["Similar to guard_1, but type-correct"];
<a name=guard_2>   84:<b>guard_2</b></a>(suite) -&gt;
   85:    [];
<a name=guard_2>   86:<b>guard_2</b></a>(Config) when list(Config) -&gt;
   87:    ?line {ok,Tokens ,_} =
   88:	erl_scan:string("if 6+4 == 4 -&gt; yes; true -&gt; no end. "),
   89:    ?line {ok, [Expr]} = erl_parse:parse_exprs(Tokens),
<a name="90"></a>   90:    ?line no = guard_2_compiled(),
   91:    ?line {value, no, []} = erl_eval:expr(Expr, []),
   92:    ok.
   93:
<a name=guard_2_compiled>   94:<b>guard_2_compiled</b></a>() -&gt;
   95:    if 6+4 == 4 -&gt; yes; true -&gt; no end.
   96:
<a name=string_plusplus>   97:<b>string_plusplus</b></a>(doc) -&gt;
   98:    ["OTP-3069: syntactic sugar string ++ ..."];
<a name=string_plusplus>   99:<b>string_plusplus</b></a>(suite) -&gt;
<a name="100"></a>  100:    [];
<a name=string_plusplus>  101:<b>string_plusplus</b></a>(Config) when list(Config) -&gt;
  102:    ?line check(fun() -&gt; case "abc" of "ab" ++ L -&gt; L end end,
  103:		"case \"abc\" of \"ab\" ++ L -&gt; L end. ",
  104:		"c"),
  105:    ?line check(fun() -&gt; case "abcde" of "ab" ++ "cd" ++ L -&gt; L end end,
  106:		"case \"abcde\" of \"ab\" ++ \"cd\" ++ L -&gt; L end. ",
  107:		"e"),
  108:    ?line check(fun() -&gt; case "abc" of [97, 98] ++ L -&gt; L end end,
  109:		"case \"abc\" of [97, 98] ++ L -&gt; L end. ",
<a name="110"></a>  110:		"c"),
  111:    ok.
  112:
<a name=match_pattern>  113:<b>match_pattern</b></a>(doc) -&gt;
  114:    ["OTP-2983: match operator in pattern"];
<a name=match_pattern>  115:<b>match_pattern</b></a>(suite) -&gt;
  116:    [];
<a name=match_pattern>  117:<b>match_pattern</b></a>(Config) when list(Config) -&gt;
  118:    ?line check(fun() -&gt; case {a, b} of {a, _X}=Y -&gt; {x,Y} end end,
  119:		"case {a, b} of {a, X}=Y -&gt; {x,Y} end. ",
<a name="120"></a>  120:		{x, {a, b}}),
  121:    ?line check(fun() -&gt; case {a, b} of Y={a, _X} -&gt; {x,Y} end end,
  122:		"case {a, b} of Y={a, X} -&gt; {x,Y} end. ",
  123:		{x, {a, b}}),
  124:    ?line check(fun() -&gt; case {a, b} of Y={a, _X}=Z -&gt; {Z,Y} end end,
  125:		"case {a, b} of Y={a, X}=Z -&gt; {Z,Y} end. ",
  126:		{{a, b}, {a, b}}),
  127:    ?line check(fun() -&gt; A = 4, B = 28, &lt;&lt;13:(A+(X=B))&gt;&gt;, X end,
  128:                "begin A = 4, B = 28, &lt;&lt;13:(A+(X=B))&gt;&gt;, X end.",
  129:                28),
<a name="130"></a>  130:    ok.
  131:
<a name=match_bin>  132:<b>match_bin</b></a>(doc) -&gt;
  133:    ["binary match problems"];
<a name=match_bin>  134:<b>match_bin</b></a>(suite) -&gt;
  135:    [];
<a name=match_bin>  136:<b>match_bin</b></a>(Config) when list(Config) -&gt;
  137:    ?line check(fun() -&gt; &lt;&lt;"abc"&gt;&gt; = &lt;&lt;"abc"&gt;&gt; end,
  138:		"&lt;&lt;\"abc\"&gt;&gt; = &lt;&lt;\"abc\"&gt;&gt;. ",
  139:		&lt;&lt;"abc"&gt;&gt;),
<a name="140"></a>  140:    ?line check(fun() -&gt;
  141:			&lt;&lt;Size,B:Size/binary,Rest/binary&gt;&gt; = &lt;&lt;2,"AB","CD"&gt;&gt;,
  142:			{Size,B,Rest}
  143:		end,
  144:		"begin &lt;&lt;Size,B:Size/binary,Rest/binary&gt;&gt; = &lt;&lt;2,\"AB\",\"CD\"&gt;&gt;, "
  145:		"{Size,B,Rest} end. ",
  146:		{2,&lt;&lt;"AB"&gt;&gt;,&lt;&lt;"CD"&gt;&gt;}),
  147:    ok.
  148:
<a name=pattern_expr>  149:<b>pattern_expr</b></a>(doc) -&gt;
<a name="150"></a>  150:    ["OTP-3144: compile-time expressions in pattern"];
<a name=pattern_expr>  151:<b>pattern_expr</b></a>(suite) -&gt;
  152:    [];
<a name=pattern_expr>  153:<b>pattern_expr</b></a>(Config) when list(Config) -&gt;
  154:    ?line check(fun() -&gt; case 4 of 2+2 -&gt; ok end end,
  155:		"case 4 of 2+2 -&gt; ok end. ",
  156:		ok),
  157:    ?line check(fun() -&gt; case 2 of +2 -&gt; ok end end,
  158:		"case 2 of +2 -&gt; ok end. ",
  159:		ok),
<a name="160"></a>  160:    ok.
  161:
<a name=guard_3>  162:<b>guard_3</b></a>(doc) -&gt;
  163:    ["OTP-4518."];
<a name=guard_3>  164:<b>guard_3</b></a>(suite) -&gt;
  165:    [];
<a name=guard_3>  166:<b>guard_3</b></a>(Config) when list(Config) -&gt;
  167:    ?line check(fun() -&gt; if false -&gt; false; true -&gt; true end end,
  168:                "if false -&gt; false; true -&gt; true end.",
  169:                true),
<a name="170"></a>  170:    ?line check(fun() -&gt; if &lt;&lt;"hej"&gt;&gt; == &lt;&lt;"hopp"&gt;&gt; -&gt; true; 
  171:                            true -&gt; false end end,
  172:                "begin if &lt;&lt;\"hej\"&gt;&gt; == &lt;&lt;\"hopp\"&gt;&gt; -&gt; true; 
  173:                          true -&gt; false end end.",
  174:                false),
  175:    ?line check(fun() -&gt; if &lt;&lt;"hej"&gt;&gt; == &lt;&lt;"hej"&gt;&gt; -&gt; true; 
  176:                            true -&gt; false end end,
  177:                "begin if &lt;&lt;\"hej\"&gt;&gt; == &lt;&lt;\"hej\"&gt;&gt; -&gt; true; 
  178:                          true -&gt; false end end.",
  179:                true),
<a name="180"></a>  180:    ok.
  181:
<a name=lc>  182:<b>lc</b></a>(doc) -&gt;
  183:    ["OTP-4518."];
<a name=lc>  184:<b>lc</b></a>(suite) -&gt;
  185:    [];
<a name=lc>  186:<b>lc</b></a>(Config) when list(Config) -&gt;
  187:    ?line check(fun() -&gt; X = 32, [X || X &lt;- [1,2,3]] end,
  188:                "begin X = 32, [X || X &lt;- [1,2,3]] end.",
  189:                [1,2,3]),
<a name="190"></a>  190:    ?line check(fun() -&gt; X = 32, 
  191:                         [X || &lt;&lt;X:X&gt;&gt; &lt;- [&lt;&lt;1:32&gt;&gt;,&lt;&lt;2:32&gt;&gt;,&lt;&lt;3:8&gt;&gt;]] end,
  192:    %% "binsize variable"          ^
  193:                "begin X = 32, 
  194:                 [X || &lt;&lt;X:X&gt;&gt; &lt;- [&lt;&lt;1:32&gt;&gt;,&lt;&lt;2:32&gt;&gt;,&lt;&lt;3:8&gt;&gt;]] end.",
  195:                [1,2]),
  196:    ?line check(fun() -&gt; Y = 13,[X || {X,Y} &lt;- [{1,2}]] end,
  197:                "begin Y = 13,[X || {X,Y} &lt;- [{1,2}]] end.",
  198:                [1]),
  199:    ?line error_check("begin [A || X &lt;- [{1,2}], 1 == A] end.",
<a name="200"></a>  200:                      {unbound_var,'A'}),
  201:    ?line error_check("begin X = 32, 
  202:                        [{Y,W} || X &lt;- [1,2,32,Y=4], Z &lt;- [1,2,W=3]] end.",
  203:                      {unbound_var,'Y'}),
  204:    ?line error_check("begin X = 32,&lt;&lt;A:B&gt;&gt; = &lt;&lt;100:X&gt;&gt; end.",
  205:                      {unbound_var,'B'}),
  206:    ?line check(fun() -&gt; [X || X &lt;- [1,2,3,4], not (X &lt; 2)] end,
  207:                "begin [X || X &lt;- [1,2,3,4], not (X &lt; 2)] end.",
  208:                [2,3,4]),
  209:    ?line check(fun() -&gt; [X || X &lt;- [true,false], X] end,
<a name="210"></a>  210:                "[X || X &lt;- [true,false], X].", [true]),
  211:    ok.
  212:
<a name=simple_cases>  213:<b>simple_cases</b></a>(doc) -&gt;
  214:    ["Simple cases, just to cover some code."];
<a name=simple_cases>  215:<b>simple_cases</b></a>(suite) -&gt;
  216:    [];
<a name=simple_cases>  217:<b>simple_cases</b></a>(Config) when list(Config) -&gt;
  218:    ?line check(fun() -&gt; A = $C end, "A = $C.", $C),
  219:    %% ?line check(fun() -&gt; A = 3.14 end, "A = 3.14.", 3.14),
<a name="220"></a>  220:    %% try...
  221:    ?line check(fun() -&gt; self() ! a, A = receive a -&gt; true end end,
  222:                "begin self() ! a, A = receive a -&gt; true end end.",
  223:                true),
  224:    ?line check(fun() -&gt; c:flush(), self() ! a, self() ! b, self() ! c,
  225:                         receive b -&gt; b end, 
  226:                         {messages, [a,c]} ==
  227:                             erlang:process_info(self(), messages),
  228:                         c:flush() end,
  229:                "begin c:flush(), self() ! a, self() ! b, self() ! c,"
<a name="230"></a>  230:                "receive b -&gt; b end,"
  231:                "{messages, [a,c]} =="
  232:                "     erlang:process_info(self(), messages), c:flush() end.",
  233:                ok),
  234:    ?line check(fun() -&gt; self() ! a, A = receive a -&gt; true 
  235:                                         after 0 -&gt; false end end,
  236:                "begin self() ! a, A = receive a -&gt; true"
  237:                "                      after 0 -&gt; false end end.",
  238:                true),
  239:    ?line check(fun() -&gt; c:flush(), self() ! a, self() ! b, self() ! c,
<a name="240"></a>  240:                         receive b -&gt; b after 0 -&gt; true end, 
  241:                         {messages, [a,c]} ==
  242:                             erlang:process_info(self(), messages),
  243:                         c:flush() end,
  244:                "begin c:flush(), self() ! a, self() ! b, self() ! c,"
  245:                "receive b -&gt; b after 0 -&gt; true end,"
  246:                "{messages, [a,c]} =="
  247:                "     erlang:process_info(self(), messages), c:flush() end.",
  248:                ok),
  249:    ?line check(fun() -&gt; receive _ -&gt; true after 10 -&gt; false end end,
<a name="250"></a>  250:                "receive _ -&gt; true after 10 -&gt; false end.",
  251:                false),
  252:    ?line check(fun() -&gt; F = fun(A) -&gt; A end, true = 3 == F(3) end,
  253:                "begin F = fun(A) -&gt; A end, true = 3 == F(3) end.",
  254:                true),
  255:    ?line check(fun() -&gt; F = fun(A) -&gt; A end, true = 3 == apply(F, [3]) end,
  256:                "begin F = fun(A) -&gt; A end, true = 3 == apply(F,[3]) end.",
  257:                true),
  258:    ?line check(fun() -&gt; catch throw(a) end, "catch throw(a).", a),
  259:    ?line check(fun() -&gt; catch a end, "catch a.", a),
<a name="260"></a>  260:    ?line check(fun() -&gt; 4 == 3 end, "4 == 3.", false),
  261:    ?line check(fun() -&gt; not true end, "not true.", false),
  262:    ?line check(fun() -&gt; -3 end, "-3.", -3),
  263:    ?line check(fun() -&gt; false andalso kludd end, "false andalso kludd.",
  264:                false),
  265:    ?line check(fun() -&gt; true andalso true end, "true andalso true.",
  266:                true),
  267:    ?line check(fun() -&gt; true andalso false end, "true andalso false.",
  268:                false),
  269:    ?line error_check("kladd andalso kludd.", {badarg,kladd}),
<a name="270"></a>  270:    ?line error_check("true andalso kludd.", {badarg,kludd}),
  271:    ?line check(fun() -&gt; true orelse kludd end, 
  272:                "true orelse kludd.", true),
  273:    ?line check(fun() -&gt; false orelse false end, 
  274:                "false orelse false.", false),
  275:    ?line check(fun() -&gt; false orelse true end, 
  276:                "false orelse true.", true),
  277:    ?line error_check("kladd orelse kludd.", {badarg,kladd}),
  278:    ?line error_check("false orelse kludd.", {badarg,kludd}),
  279:    ?line error_check("[X || X &lt;- [1,2,3], erlang:process_info(self())].",
<a name="280"></a>  280:                      bad_filter),
  281:
  282:    %% Just adopting to the R9-compiler: (filters are _not_ guards!)
  283:    ?line check(fun() -&gt; [X || X &lt;- [1,2,3], X+2] end,
  284:                "[X || X &lt;- [1,2,3], X+2].", []),
  285:
  286:    ?line check(fun() -&gt; [X || X &lt;- [1,2,3], [X] == [X || X &lt;- [2]]] end,
  287:                "[X || X &lt;- [1,2,3], [X] == [X || X &lt;- [2]]].",
  288:                [2]),
  289:    ?line check(fun() -&gt; F = fun(1) -&gt; ett; (2) -&gt; zwei end, 
<a name="290"></a>  290:                         ett = F(1), zwei = F(2) end,
  291:                "begin F = fun(1) -&gt; ett; (2) -&gt; zwei end, 
  292:                         ett = F(1), zwei = F(2) end.",
  293:                zwei),
  294:    ?line check(fun() -&gt; F = fun(X) when X == 1 -&gt; ett; 
  295:                                (X) when X == 2 -&gt; zwei end, 
  296:                         ett = F(1), zwei = F(2) end,
  297:                "begin F = fun(X) when X == 1 -&gt; ett; 
  298:                              (X) when X == 2 -&gt; zwei end, 
  299:                         ett = F(1), zwei = F(2) end.",
<a name="300"></a>  300:                zwei),
  301:    ?line error_check("begin F = fun(1) -&gt; ett end, zwei = F(2) end.",
  302:                      function_clause),
  303:    ?line check(fun() -&gt; if length([1]) == 1 -&gt; yes; 
  304:                            true -&gt; no end end,
  305:                "if length([1]) == 1 -&gt; yes; 
  306:                            true -&gt; no end.",
  307:                yes),
  308:    ?line check(fun() -&gt; if is_integer(3) -&gt; true; true -&gt; false end end,
  309:                "if is_integer(3) -&gt; true; true -&gt; false end.", true),
<a name="310"></a>  310:    ?line check(fun() -&gt; if integer(3) -&gt; true; true -&gt; false end end,
  311:                "if integer(3) -&gt; true; true -&gt; false end.", true),
  312:    ?line check(fun() -&gt; if is_float(3) -&gt; true; true -&gt; false end end,
  313:                "if is_float(3) -&gt; true; true -&gt; false end.", false),
  314:    ?line check(fun() -&gt; if float(3) -&gt; true; true -&gt; false end end,
  315:                "if float(3) -&gt; true; true -&gt; false end.", false),
  316:    ?line check(fun() -&gt; if is_number(3) -&gt; true; true -&gt; false end end,
  317:                "if is_number(3) -&gt; true; true -&gt; false end.", true),
  318:    ?line check(fun() -&gt; if number(3) -&gt; true; true -&gt; false end end,
  319:                "if number(3) -&gt; true; true -&gt; false end.", true),
<a name="320"></a>  320:    ?line check(fun() -&gt; if is_atom(a) -&gt; true; true -&gt; false end end,
  321:                "if is_atom(a) -&gt; true; true -&gt; false end.", true),
  322:    ?line check(fun() -&gt; if atom(a) -&gt; true; true -&gt; false end end,
  323:                "if atom(a) -&gt; true; true -&gt; false end.", true),
  324:    ?line check(fun() -&gt; if is_constant(a) -&gt; true; true -&gt; false end end,
  325:                "if is_constant(a) -&gt; true; true -&gt; false end.", true),
  326:    ?line check(fun() -&gt; if constant(a) -&gt; true; true -&gt; false end end,
  327:                "if constant(a) -&gt; true; true -&gt; false end.", true),
  328:    ?line check(fun() -&gt; if is_list([]) -&gt; true; true -&gt; false end end,
  329:                "if is_list([]) -&gt; true; true -&gt; false end.", true),
<a name="330"></a>  330:    ?line check(fun() -&gt; if list([]) -&gt; true; true -&gt; false end end,
  331:                "if list([]) -&gt; true; true -&gt; false end.", true),
  332:    ?line check(fun() -&gt; if is_tuple({}) -&gt; true; true -&gt; false end end,
  333:                "if is_tuple({}) -&gt; true; true -&gt; false end.", true),
  334:    ?line check(fun() -&gt; if tuple({}) -&gt; true; true -&gt; false end end,
  335:                "if tuple({}) -&gt; true; true -&gt; false end.", true),
  336:    ?line check(fun() -&gt; if is_pid(self()) -&gt; true; true -&gt; false end end,
  337:                "if is_pid(self()) -&gt; true; true -&gt; false end.", true),
  338:    ?line check(fun() -&gt; if pid(self()) -&gt; true; true -&gt; false end end,
  339:                "if pid(self()) -&gt; true; true -&gt; false end.", true),
<a name="340"></a>  340:    ?line check(fun() -&gt; R = make_ref(), if is_reference(R) -&gt; true; 
  341:                                            true -&gt; false end end,
  342:                "begin R = make_ref(), if is_reference(R) -&gt; true;"
  343:                "true -&gt; false end end.", true),
  344:    ?line check(fun() -&gt; R = make_ref(), if reference(R) -&gt; true; 
  345:                                            true -&gt; false end end,
  346:                "begin R = make_ref(), if reference(R) -&gt; true;"
  347:                "true -&gt; false end end.", true),
  348:    ?line check(fun() -&gt; if is_port(a) -&gt; true; true -&gt; false end end,
  349:                "if is_port(a) -&gt; true; true -&gt; false end.", false),
<a name="350"></a>  350:    ?line check(fun() -&gt; if port(a) -&gt; true; true -&gt; false end end,
  351:                "if port(a) -&gt; true; true -&gt; false end.", false),
  352:    ?line check(fun() -&gt; if is_function(a) -&gt; true; true -&gt; false end end,
  353:                "if is_function(a) -&gt; true; true -&gt; false end.", false),
  354:    ?line check(fun() -&gt; if function(a) -&gt; true; true -&gt; false end end,
  355:                "if function(a) -&gt; true; true -&gt; false end.", false),
  356:    ?line check(fun() -&gt; if is_binary(&lt;&lt;&gt;&gt;) -&gt; true; true -&gt; false end end,
  357:                "if is_binary(&lt;&lt;&gt;&gt;) -&gt; true; true -&gt; false end.", true),
  358:    ?line check(fun() -&gt; if binary(&lt;&lt;&gt;&gt;) -&gt; true; true -&gt; false end end,
  359:                "if binary(&lt;&lt;&gt;&gt;) -&gt; true; true -&gt; false end.", true),
<a name="360"></a>  360:    ?line check(fun() -&gt; if is_integer(a) == true -&gt; yes; 
  361:                            true -&gt; no end end,
  362:                "if is_integer(a) == true -&gt; yes; 
  363:                            true -&gt; no end.",
  364:                no),
  365:    ?line check(fun() -&gt; if [] -&gt; true; true -&gt; false end end,
  366:                "if [] -&gt; true; true -&gt; false end.", false),
  367:    ?line error_check("if lists:member(1,[1]) -&gt; true; true -&gt; false end.",
  368:                      illegal_guard_expr),
  369:    ?line error_check("if false -&gt; true end.", if_clause),
<a name="370"></a>  370:    ?line check(fun() -&gt; if a+b -&gt; true; true -&gt; false end end,
  371:                "if a + b -&gt; true; true -&gt; false end.", false),
  372:    ?line check(fun() -&gt; if + b -&gt; true; true -&gt; false end end,
  373:                "if + b -&gt; true; true -&gt; false end.", false),
  374:    ?line error_check("case foo of bar -&gt; true end.", {case_clause,foo}),
  375:    ?line error_check("case 4 of 2+a -&gt; true; _ -&gt; false end.", 
  376:                      illegal_pattern),
  377:    ?line error_check("case 4 of +a -&gt; true; _ -&gt; false end.", 
  378:                      illegal_pattern),
  379:    ?line check(fun() -&gt; case a of 
<a name="380"></a>  380:                             X when X == b -&gt; one;
  381:                             X when X == a -&gt; two
  382:                         end end,
  383:                "begin case a of 
  384:                             X when X == b -&gt; one;
  385:                             X when X == a -&gt; two
  386:                         end end.", two),
  387:    ?line error_check("3 = 4.", {badmatch,4}),
  388:    ?line error_check("a = 3.", {badmatch,3}),
  389:    %% ?line error_check("3.1 = 2.7.",{badmatch,2.7}),
<a name="390"></a>  390:    ?line error_check("$c = 4.", {badmatch,4}),
  391:    ?line check(fun() -&gt; $c = $c end, "$c = $c.", $c),
  392:    ?line check(fun() -&gt; _ = bar end, "_ = bar.", bar),
  393:    ?line check(fun() -&gt; A = 14, A = 14 end, 
  394:                "begin A = 14, A = 14 end.", 14),
  395:    ?line error_check("begin A = 14, A = 16 end.", {badmatch,16}),
  396:    ?line error_check("\"hej\" = \"san\".", {badmatch,"san"}),
  397:    ?line check(fun() -&gt; "hej" = "hej" end,
  398:                "\"hej\" = \"hej\".", "hej"),
  399:    ?line error_check("[] = [a].", {badmatch,[a]}),
<a name="400"></a>  400:    ?line check(fun() -&gt; [] = [] end, "[] = [].", []),
  401:    ?line error_check("[a] = [].", {badmatch,[]}),
  402:    ?line error_check("{a,b} = 34.", {badmatch,34}),
  403:    ?line error_check("&lt;&lt;8:7&gt;&gt;.", badarg),
  404:    ?line error_check("&lt;&lt;34:32&gt;&gt; = \"hej\".", {badmatch,"hej"}),
  405:    ?line check(fun() -&gt; trunc((1 * 3 div 3 + 4 - 3) / 1) rem 2 end,
  406:                "begin trunc((1 * 3 div 3 + 4 - 3) / 1) rem 2 end.", 0),
  407:    ?line check(fun() -&gt; (2#101 band 2#10101) bor (2#110 bxor 2#010) end,
  408:                "(2#101 band 2#10101) bor (2#110 bxor 2#010).", 5),
  409:    ?line check(fun() -&gt; (2#1 bsl 4) + (2#10000 bsr 3) end,
<a name="410"></a>  410:                "(2#1 bsl 4) + (2#10000 bsr 3).", 18),
  411:    ?line check(fun() -&gt; ((1&lt;3) and ((1 =:= 2) or (1 =/= 2))) xor (1=&lt;2) end,
  412:                "((1&lt;3) and ((1 =:= 2) or (1 =/= 2))) xor (1=&lt;2).", false),
  413:    ?line check(fun() -&gt; (a /= b) or (2 &gt; 4) or (3 &gt;= 3) end,
  414:                "(a /= b) or (2 &gt; 4) or (3 &gt;= 3).", true),
  415:    ?line check(fun() -&gt; "hej" ++ "san" =/= "hejsan" -- "san" end,
  416:                "\"hej\" ++ \"san\" =/= \"hejsan\" -- \"san\".", true),
  417:    ?line check(fun() -&gt; (bnot 1) &lt; -0 end, "(bnot (+1)) &lt; -0.", true),
  418:    ok.
  419:
<a name=funs><a name="420"></a>  420:<b>funs</b></a>(doc) -&gt;
  421:    ["Simple cases, just to cover some code."];
<a name=funs>  422:<b>funs</b></a>(suite) -&gt;
  423:    [];
<a name=funs>  424:<b>funs</b></a>(Config) when list(Config) -&gt;
  425:    do_funs(none, none),
  426:    do_funs(lfh(), none),
  427:    do_funs(lfh(), efh()),
  428:
  429:    ?line error_check("nix:foo().", {access_not_allowed,nix}, lfh(), efh()),
<a name="430"></a>  430:    ?line error_check("bar().", undef, none, none),
  431:
  432:    ?line check(fun() -&gt; F1 = fun(F,N) -&gt; ?MODULE:count_down(F, N) end,
  433:                         F1(F1, 1000) end,
  434:                "begin F1 = fun(F,N) -&gt; count_down(F, N) end,"
  435:                "F1(F1,1000) end.",
  436:		0, ['F1'], lfh(), none),
  437:
  438:    ?line check(fun() -&gt; F1 = fun(F,N) -&gt; ?MODULE:count_down(F, N) end,
  439:                         F1(F1, 1000) end,
<a name="440"></a>  440:                "begin F1 = fun(F,N) -&gt; count_down(F, N) end,"
  441:                "F1(F1,1000) end.",
  442:		0, ['F1'], lfh_value(), none),
  443:
  444:    ?line check(fun() -&gt; F1 = fun(F,N) -&gt; ?MODULE:count_down(F, N) end,
  445:                         F1(F1, 1000) end,
  446:                "begin F1 = fun(F,N) -&gt; count_down(F, N) end,"
  447:                "F1(F1,1000) end.",
  448:		0, ['F1'], lfh_value_extra(), none),
  449:
<a name="450"></a>  450:    ?line check(fun() -&gt; F1 = fun(F,N) -&gt; ?MODULE:count_down(F, N) end,
  451:                         F1(F1, 1000) end,
  452:                "begin F1 = fun(F,N) -&gt; count_down(F, N) end,"
  453:                "F1(F1,1000) end.",
  454:		0, ['F1'], {?MODULE,local_func_value}, none),
  455:    %% This is not documented, and only for backward compatibility (good!).
  456:    B0 = erl_eval:new_bindings(),
  457:    ?line check(fun() -&gt; is_function(?MODULE:count_down_fun()) end,
  458:                "begin is_function(count_down_fun()) end.",
  459:                true, [], {?MODULE,local_func,[B0]},none),
<a name="460"></a>  460:
  461:    ok.
  462:
<a name=do_funs>  463:<b>do_funs</b></a>(LFH, EFH) -&gt;
  464:    %% LFH is not really used by these examples...
  465:
  466:    %% These tests do not prove that tail recursive functions really
  467:    %% work (that the process does not grow); one should also run them
  468:    %% manually with 1000 replaced by 1000000.
  469:
<a name="470"></a>  470:    M = atom_to_list(?MODULE),
  471:    ?line check(fun() -&gt; F1 = fun(F,N) -&gt; ?MODULE:count_down(F, N) end,
  472:                         F1(F1, 1000) end,
  473:                concat(["begin F1 = fun(F,N) -&gt; ", M, 
  474:                        ":count_down(F, N) end, F1(F1,1000) end."]),
  475:		0, ['F1'], LFH, EFH),
  476:    ?line check(fun() -&gt; F1 = fun(F,N) -&gt; apply(?MODULE,count_down,[F,N]) 
  477:                              end, F1(F1, 1000) end,
  478:                concat(["begin F1 = fun(F,N) -&gt; apply(", M, 
  479:                        ",count_down,[F, N]) end, F1(F1,1000) end."]),
<a name="480"></a>  480:		0, ['F1'], LFH, EFH),
  481:    ?line check(fun() -&gt; F1 = fun(F,N) -&gt; {?MODULE,count_down}(F,N)
  482:                              end, F1(F1, 1000) end,
  483:                concat(["begin F1 = fun(F,N) -&gt; {", M, 
  484:                        ",count_down}(F, N) end, F1(F1,1000) end."]),
  485:		0, ['F1'], LFH, EFH),
  486:    ?line check(fun() -&gt; F = fun(F,N) when N &gt; 0 -&gt; apply(F,[F,N-1]); 
  487:                                (_F,0) -&gt; ok end, 
  488:                         F(F, 1000)
  489:                end,
<a name="490"></a>  490:                "begin F = fun(F,N) when N &gt; 0 -&gt; apply(F,[F,N-1]);"
  491:                             "(_F,0) -&gt; ok end,"
  492:                       "F(F, 1000) end.",
  493:                ok, ['F'], LFH, EFH),
  494:    ?line check(fun() -&gt; F = fun(F,N) when N &gt; 0 -&gt; 
  495:                                     apply(erlang,apply,[F,[F,N-1]]);
  496:                                (_F,0) -&gt; ok end, 
  497:                         F(F, 1000)
  498:                end,
  499:                "begin F = fun(F,N) when N &gt; 0 -&gt;"
<a name="500"></a>  500:                                   "apply(erlang,apply,[F,[F,N-1]]);"
  501:                             "(_F,0) -&gt; ok end,"
  502:                       "F(F, 1000) end.",
  503:                ok, ['F'], LFH, EFH),
  504:    ?line check(fun() -&gt; F = count_down_fun(), 
  505:                         SF = fun(SF, F1, N) -&gt; F(SF, F1, N) end,
  506:                         SF(SF, F, 1000) end,
  507:                concat(["begin F = ", M, ":count_down_fun(),"
  508:                        "SF = fun(SF, F1, N) -&gt; F(SF, F1, N) end,"
  509:                        "SF(SF, F, 1000) end."]),
<a name="510"></a>  510:                ok, ['F','SF'], LFH, EFH),
  511:
  512:
  513:    ?line check(fun() -&gt; F = fun(X) -&gt; A = 1+X, {X,A} end, 
  514:                         true = {2,3} == F(2) end,
  515:                "begin F = fun(X) -&gt; A = 1+X, {X,A} end, 
  516:                       true = {2,3} == F(2) end.", true, ['F'], LFH, EFH),
  517:    ?line check(fun() -&gt; F = fun(X) -&gt; {erlang,'+'}(X,2) end, 
  518:                         true = 3 == F(1) end,
  519:                "begin F = fun(X) -&gt; {erlang,'+'}(X,2) end," 
<a name="520"></a>  520:                "      true = 3 == F(1) end.", true, ['F'],
  521:               LFH, EFH),
  522:    ?line check(fun() -&gt; F = fun(X) -&gt; size(X) end,
  523:                         ?MODULE:do_apply(F,&lt;&lt;"hej"&gt;&gt;) end, 
  524:                concat(["begin F = fun(X) -&gt; size(X) end,",
  525:                        M,":do_apply(F,&lt;&lt;\"hej\"&gt;&gt;) end."]),
  526:                3, ['F'], LFH, EFH),
  527:
  528:    ?line check(fun() -&gt; F1 = fun(X, Z) -&gt; {X,Z} end,
  529:                         Z = 5,
<a name="530"></a>  530:                         F2 = fun(X, Y) -&gt; F1(Z,{X,Y}) end,
  531:                         F3 = fun(X, Y) -&gt; {a,F1(Z,{X,Y})} end,
  532:                         {5,{x,y}} = F2(x,y), 
  533:                         {a,{5,{y,x}}} = F3(y,x), 
  534:                         {5,{5,y}} = F2(Z,y), 
  535:                         true = {5,{x,5}} == F2(x,Z) end,
  536:                "begin F1 = fun(X, Z) -&gt; {X,Z} end,
  537:                       Z = 5,
  538:                       F2 = fun(X, Y) -&gt; F1(Z,{X,Y}) end,
  539:                       F3 = fun(X, Y) -&gt; {a,F1(Z,{X,Y})} end,
<a name="540"></a>  540:                       {5,{x,y}} = F2(x,y), 
  541:                       {a,{5,{y,x}}} = F3(y,x), 
  542:                       {5,{5,y}} = F2(Z,y), 
  543:                       true = {5,{x,5}} == F2(x,Z) end.",
  544:                true, ['F1','Z','F2','F3'], LFH, EFH),
  545:    ?line check(fun() -&gt; F = fun(X) -&gt; size(X) end,
  546:                         F2 = fun(Y) -&gt; F(Y) end,
  547:                         ?MODULE:do_apply(F2,&lt;&lt;"hej"&gt;&gt;) end, 
  548:                concat(["begin F = fun(X) -&gt; size(X) end,",
  549:                        "F2 = fun(Y) -&gt; F(Y) end,",
<a name="550"></a>  550:                        M,":do_apply(F2,&lt;&lt;\"hej\"&gt;&gt;) end."]),
  551:                3, ['F','F2'], LFH, EFH),
  552:    ?line check(fun() -&gt; Z = 5, F = fun(X) -&gt; {Z,X} end,
  553:                         F2 = fun(Z) -&gt; F(Z) end, F2(3) end,
  554:                "begin Z = 5, F = fun(X) -&gt; {Z,X} end,
  555:                       F2 = fun(Z) -&gt; F(Z) end, F2(3) end.",
  556:                {5,3},['F','F2','Z'], LFH, EFH),
  557:    ?line check(fun() -&gt; F = fun(Z) -&gt; Z end,
  558:                         F2 = fun(X) -&gt; F(X), Z = {X,X}, Z end,
  559:                         {1,1} = F2(1), Z = 7, Z end,
<a name="560"></a>  560:                "begin F = fun(Z) -&gt; Z end,
  561:                       F2 = fun(X) -&gt; F(X), Z = {X,X}, Z end,
  562:                       {1,1} = F2(1), Z = 7, Z end.", 7, ['F','F2','Z'], 
  563:                LFH, EFH),
  564:    ?line check(fun() -&gt; F = fun(F, N) -&gt; [?MODULE:count_down(F,N) || X &lt;-[1]]
  565:                             end, F(F,2) end,
  566:                concat(["begin F = fun(F, N) -&gt; [", M, 
  567:                       ":count_down(F,N) || X &lt;-[1]] end, F(F,2) end."]),
  568:                [[[0]]], ['F'], LFH, EFH),
  569:    
<a name="570"></a>  570:    ok.
  571:
<a name=count_down>  572:<b>count_down</b></a>(F, N) when N &gt; 0 -&gt;
  573:    F(F, N-1);
<a name=count_down>  574:<b>count_down</b></a>(_F, N) -&gt;
  575:    N.
  576:
<a name=count_down_fun>  577:<b>count_down_fun</b></a>() -&gt;
  578:    fun(SF,F,N) when N &gt; 0 -&gt; SF(SF,F,N-1);
  579:       (_SF,_F,_N) -&gt; ok
<a name="580"></a>  580:    end.
  581:
<a name=do_apply>  582:<b>do_apply</b></a>(F, V) -&gt;
  583:    F(V).
  584:
<a name=lfh>  585:<b>lfh</b></a>() -&gt;
  586:    {eval, fun(F, As, Bs) -&gt; local_func(F, As, Bs) end}.
  587:
<a name=local_func>  588:<b>local_func</b></a>(F, As0, Bs0) when atom(F) -&gt;
  589:    {As,Bs} = erl_eval:expr_list(As0, Bs0, {eval,lfh()}),
<a name="590"></a>  590:    case erlang:function_exported(?MODULE, F, length(As)) of
  591:	true -&gt;
  592:	    {value,apply(?MODULE, F, As),Bs};
  593:	false -&gt;
  594:	    {value,apply(shell_default, F, As),Bs}
  595:    end.
  596:
<a name=lfh_value_extra>  597:<b>lfh_value_extra</b></a>() -&gt;
  598:    %% Not documented.
  599:    {value, fun(F, As) -&gt; local_func_value(F, As) end, []}.
<a name="600"></a>  600:
<a name=lfh_value>  601:<b>lfh_value</b></a>() -&gt;
  602:    {value, fun(F, As) -&gt; local_func_value(F, As) end}.
  603:
<a name=local_func_value>  604:<b>local_func_value</b></a>(F, As) when atom(F) -&gt;
  605:    case erlang:function_exported(?MODULE, F, length(As)) of
  606:	true -&gt;
  607:	    apply(?MODULE, F, As);
  608:	false -&gt;
  609:	    apply(shell_default, F, As)
<a name="610"></a>  610:    end.
  611:
<a name=efh>  612:<b>efh</b></a>() -&gt;
  613:    {value, fun(F, As) -&gt; external_func(F, As) end}.
  614:
<a name=external_func>  615:<b>external_func</b></a>({M,_}, _As) when M == nix -&gt;
  616:    exit({{access_not_allowed,M},[mfa]});
<a name=external_func>  617:<b>external_func</b></a>(F, As) when function(F) -&gt;
  618:    apply(F, As);
<a name=external_func>  619:<b>external_func</b></a>({M,F}, As) -&gt;
<a name="620"></a>  620:    apply(M, F, As).
  621:
<a name=check>  622:<b>check</b></a>(F, String, Result) -&gt;
  623:    ?line {ok,Tokens,_} =
  624:	erl_scan:string(String),
  625:    ?line {ok, [Expr]} = erl_parse:parse_exprs(Tokens),
  626:    ?line Result = F(),
  627:    ?line case catch erl_eval:expr(Expr, []) of
  628:	      {value, Result, _} -&gt;
  629:		  ok;
<a name="630"></a>  630:	      Other -&gt;
  631:		  test_server:fail({eval, Other, Result})
  632:	  end,
  633:    ok.
  634:
<a name=check>  635:<b>check</b></a>(F, String, Result, BoundVars, LFH, EFH) -&gt;
  636:    ?line {ok,Tokens,_} =
  637:	erl_scan:string(String),
  638:    ?line {ok, [Expr]} = erl_parse:parse_exprs(Tokens),
  639:    ?line Result = F(),
<a name="640"></a>  640:    ?line case catch erl_eval:expr(Expr, [], LFH, EFH) of
  641:	      {value, Result, Bs} -&gt;
  642:                  %% We just assume that Bs is an orddict...
  643:                  Keys = orddict:fetch_keys(Bs),
  644:                  case sort(BoundVars) == Keys of
  645:                      true -&gt; ok;
  646:                      false -&gt; 
  647:                          test_server:fail({check, BoundVars, Keys})
  648:                  end,
  649:		  ok;
<a name="650"></a>  650:	      Other -&gt;
  651:		  test_server:fail({check, Other, Result})
  652:	  end,
  653:    ok.
  654:
<a name=error_check>  655:<b>error_check</b></a>(String, Result) -&gt;
  656:    ?line {ok,Tokens,_} =
  657:	erl_scan:string(String),
  658:    ?line {ok, [Expr]} = erl_parse:parse_exprs(Tokens),
  659:    ?line case catch erl_eval:expr(Expr, []) of
<a name="660"></a>  660:              {'EXIT', {Result,_}} -&gt;
  661:                  ok;
  662:	      Other -&gt;
  663:		  test_server:fail({eval, Other, Result})
  664:	  end,
  665:    ok.
  666:
<a name=error_check>  667:<b>error_check</b></a>(String, Result, LFH, EFH) -&gt;
  668:    ?line {ok,Tokens,_} =
  669:	erl_scan:string(String),
<a name="670"></a>  670:    ?line {ok, [Expr]} = erl_parse:parse_exprs(Tokens),
  671:    ?line case catch erl_eval:expr(Expr, [], LFH, EFH) of
  672:              {'EXIT', {Result,_}} -&gt;
  673:                  ok;
  674:	      Other -&gt;
  675:		  test_server:fail({eval, Other, Result})
  676:	  end,
  677:    ok.
</pre>
<hr size=1><i>The transformation of this file (678 lines) took 0.02 seconds</i><br>
</body>
</html>

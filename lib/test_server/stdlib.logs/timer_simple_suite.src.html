<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head><title>/usr/home/jlouis/hacking/test_server/stdlib_test/timer_simple_SUITE.erl</title></head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
    1:<i>%% ``The contents of this file are subject to the Erlang Public License,</i>
    2:<i>%% Version 1.1, (the "License"); you may not use this file except in</i>
    3:<i>%% compliance with the License. You should have received a copy of the</i>
    4:<i>%% Erlang Public License along with this software. If not, it can be</i>
    5:<i>%% retrieved via the world wide web at http://www.erlang.org/.</i>
    6:<i>%% </i>
    7:<i>%% Software distributed under the License is distributed on an "AS IS"</i>
    8:<i>%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See</i>
    9:<i>%% the License for the specific language governing rights and limitations</i>
<a name="10"></a>   10:<i>%% under the License.</i>
   11:<i>%% </i>
   12:<i>%% The Initial Developer of the Original Code is Ericsson Utvecklings AB.</i>
   13:<i>%% Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings</i>
   14:<i>%% AB. All Rights Reserved.''</i>
   15:<i>%% </i>
   16:<i>%%     $Id$</i>
   17:<i>%%</i>
   18:<i>%%% Purpose : Test the timer module a simpler/faster test than timer_SUITE</i>
   19:
<a name="20"></a>   20:-<b>module</b>(timer_simple_SUITE).
   21:
   22:<i>%% external</i>
   23:-<b>export</b>([all/1, 
   24:	 init_per_testcase/2,
   25:	 apply_after/1,
   26:	 send_after1/1,
   27:	 send_after2/1,
   28:	 send_after3/1,
   29:	 exit_after1/1,
<a name="30"></a>   30:	 exit_after2/1,
   31:	 kill_after1/1,
   32:	 kill_after2/1,
   33:	 apply_interval/1,
   34:	 send_interval1/1,
   35:	 send_interval2/1,
   36:	 send_interval3/1,
   37:	 send_interval4/1,
   38:	 cancel1/1,
   39:	 cancel2/1,
<a name="40"></a>   40:	 tc/1,
   41:	 unique_refs/1,
   42:	 timer_perf/1]).
   43:
   44:<i>%% internal</i>
   45:-<b>export</b>([forever/0,
   46:	 do_nrev/2,
   47:	 send/2,
   48:	 timer/4,
   49:	 timer/5]).
<a name="50"></a>   50:
   51:-<b>include</b>("test_server.hrl").
   52:
   53:-<b>define</b>(MAXREF, (1 bsl 18)).
   54:-<b>define</b>(REFMARG, 30).
   55:
<a name=all>   56:<b>all</b></a>(doc) -&gt; "Test of the timer module.";
<a name=all>   57:<b>all</b></a>(suite) -&gt; 
   58:    [apply_after,
   59:     send_after1,
<a name="60"></a>   60:     send_after2,
   61:     send_after3,
   62:     exit_after1,
   63:     exit_after2,
   64:     kill_after1,
   65:     kill_after2,
   66:     apply_interval,
   67:     send_interval1,
   68:     send_interval2,
   69:     send_interval3,
<a name="70"></a>   70:     send_interval4,
   71:     cancel1,
   72:     cancel2,
   73:     tc,
   74:     unique_refs,
   75:     timer_perf].
   76:
<a name=init_per_testcase>   77:<b>init_per_testcase</b></a>(X, Config) when list(Config) -&gt;
   78:    timer:start(),
   79:    Config.
<a name="80"></a>   80:
   81:<i>%% Testing timer interface!!</i>
   82:
<a name=apply_after>   83:<b>apply_after</b></a>(doc) -&gt; "Test of apply_after, with sending of message.";
<a name=apply_after>   84:<b>apply_after</b></a>(suite) -&gt; [];
<a name=apply_after>   85:<b>apply_after</b></a>(Config) when list(Config) -&gt;
   86:    ?line timer:apply_after(500, ?MODULE, send, [self(), ok_apply]),
   87:    ?line ok = get_mess(1000, ok_apply).
   88:
<a name=send_after1>   89:<b>send_after1</b></a>(doc) -&gt; "Test of send_after with time = 0.";
<a name=send_after1><a name="90"></a>   90:<b>send_after1</b></a>(suite) -&gt; [];
<a name=send_after1>   91:<b>send_after1</b></a>(Config) when list(Config) -&gt;
   92:    ?line timer:send_after(0, ok_send1),
   93:    ?line ok = get_mess(1000, ok_send1).
   94:
<a name=send_after2>   95:<b>send_after2</b></a>(doc) -&gt; "Test of send_after with time = 500.";
<a name=send_after2>   96:<b>send_after2</b></a>(suite) -&gt; [];
<a name=send_after2>   97:<b>send_after2</b></a>(Config) when list(Config) -&gt;
   98:    ?line timer:send_after(500, self(), ok_send2),
   99:    ?line ok = get_mess(2000, ok_send2).
<a name="100"></a>  100:
<a name=send_after3>  101:<b>send_after3</b></a>(doc) -&gt; "Test of send_after with time = 500, with receiver "
  102:			"a registered process. [OTP-2735]";
<a name=send_after3>  103:<b>send_after3</b></a>(suite) -&gt; [];
<a name=send_after3>  104:<b>send_after3</b></a>(Config) when list(Config) -&gt;
  105:    ?line Name = list_to_atom(pid_to_list(self())),
  106:    ?line register(Name, self()),
  107:    ?line timer:send_after(500, Name, ok_send3),
  108:    ?line ok = get_mess(2000, ok_send3),
  109:    ?line unregister(Name).
<a name="110"></a>  110:
<a name=exit_after1>  111:<b>exit_after1</b></a>(doc) -&gt; "Test of exit_after with time = 1000.";
<a name=exit_after1>  112:<b>exit_after1</b></a>(suite) -&gt; [];
<a name=exit_after1>  113:<b>exit_after1</b></a>(Config) when list(Config) -&gt;
  114:    ?line process_flag(trap_exit, true),
  115:    ?line Pid = spawn_link(?MODULE, forever, []),
  116:    ?line timer:exit_after(1000, Pid, exit_test1),
  117:    ?line ok = get_mess(5000, {'EXIT', Pid, exit_test1}).
  118:
<a name=exit_after2>  119:<b>exit_after2</b></a>(doc) -&gt; "Test of exit_after with time = 1000. The process to "
<a name="120"></a>  120:			"exit is the name of a registered process. "
  121:			"[OTP-2735]";
<a name=exit_after2>  122:<b>exit_after2</b></a>(suite) -&gt; [];
<a name=exit_after2>  123:<b>exit_after2</b></a>(Config) when list(Config) -&gt;
  124:    ?line process_flag(trap_exit, true),
  125:    ?line Pid = spawn_link(?MODULE, forever, []),
  126:    ?line Name = list_to_atom(pid_to_list(Pid)),
  127:    ?line register(Name, Pid),
  128:    ?line timer:exit_after(1000, Name, exit_test2),
  129:    ?line ok = get_mess(2000, {'EXIT', Pid, exit_test2}).
<a name="130"></a>  130:
<a name=kill_after1>  131:<b>kill_after1</b></a>(doc) -&gt; "Test of kill_after with time = 1000.";
<a name=kill_after1>  132:<b>kill_after1</b></a>(suite) -&gt; [];
<a name=kill_after1>  133:<b>kill_after1</b></a>(Config) when list(Config) -&gt;
  134:    ?line process_flag(trap_exit, true),
  135:    ?line Pid = spawn_link(?MODULE, forever, []),
  136:    ?line timer:kill_after(1000, Pid),
  137:    ?line ok = get_mess(2000, {'EXIT', Pid, killed}).
  138:
<a name=kill_after2>  139:<b>kill_after2</b></a>(doc) -&gt; "Test of kill_after with time = 1000. The process to "
<a name="140"></a>  140:			"exit is the name of a registered process. "
  141:			"[OTP-2735]";
<a name=kill_after2>  142:<b>kill_after2</b></a>(suite) -&gt; [];
<a name=kill_after2>  143:<b>kill_after2</b></a>(Config) when list(Config) -&gt;
  144:    ?line process_flag(trap_exit, true),
  145:    ?line Pid = spawn_link(?MODULE, forever, []),
  146:    ?line Name = list_to_atom(pid_to_list(Pid)),
  147:    ?line register(Name, Pid),
  148:    ?line timer:kill_after(1000, Name),
  149:    ?line ok = get_mess(2000, {'EXIT', Pid, killed}).
<a name="150"></a>  150:
<a name=apply_interval>  151:<b>apply_interval</b></a>(doc) -&gt; "Test of apply_interval by sending messages. Receive "
  152:                       "3 messages, cancel the timer, and check that we do "
  153:		       "not get any more messages.";
<a name=apply_interval>  154:<b>apply_interval</b></a>(suite) -&gt; [];
<a name=apply_interval>  155:<b>apply_interval</b></a>(Config) when list(Config) -&gt;
  156:    ?line {ok, Ref} = timer:apply_interval(1000, ?MODULE, send, 
  157:				     [self(), apply_int]),
  158:    ?line ok = get_mess(1500, apply_int, 3),
  159:    ?line timer:cancel(Ref),
<a name="160"></a>  160:    ?line nor = get_mess(1000, apply_int).
  161:
<a name=send_interval1>  162:<b>send_interval1</b></a>(doc) -&gt; "Test of send_interval/2. Receive 5 messages, cancel "
  163:		      "the timer, and check that we do not get any more "
  164:                      "messages.";
<a name=send_interval1>  165:<b>send_interval1</b></a>(suite) -&gt; [];
<a name=send_interval1>  166:<b>send_interval1</b></a>(Config) when list(Config) -&gt;
  167:    {ok, Ref} = timer:send_interval(1000, send_int),
  168:    ?line ok = get_mess(1500, send_int, 5),
  169:    timer:cancel(Ref),
<a name="170"></a>  170:    ?line nor = get_mess(1000, send_int). % We should receive only five
  171:
<a name=send_interval2>  172:<b>send_interval2</b></a>(doc) -&gt; "Test of send_interval/3. Receive 2 messages, cancel "
  173:		      "the timer, and check that we do not get any more "
  174:                      "messages.";
<a name=send_interval2>  175:<b>send_interval2</b></a>(suite) -&gt; [];
<a name=send_interval2>  176:<b>send_interval2</b></a>(Config) when list(Config) -&gt;
  177:    {ok, Ref} = timer:send_interval(1000, self(), send_int2),
  178:    ?line ok = get_mess(1500, send_int2, 2),
  179:    timer:cancel(Ref),
<a name="180"></a>  180:    ?line nor = get_mess(1000, send_int2).  % We should receive only two
  181:
<a name=send_interval3>  182:<b>send_interval3</b></a>(doc) -&gt; "Test of send_interval/3. Receive 2 messages, cancel "
  183:		      "the timer, and check that we do not get any more "
  184:                      "messages. The receiver is the name of a registered "
  185:			   "process. [OTP-2735]";
<a name=send_interval3>  186:<b>send_interval3</b></a>(suite) -&gt; [];
<a name=send_interval3>  187:<b>send_interval3</b></a>(Config) when list(Config) -&gt;
  188:    ?line process_flag(trap_exit, true),
  189:    ?line Name = list_to_atom(pid_to_list(self())),
<a name="190"></a>  190:    ?line register(Name, self()),
  191:    ?line {ok, Ref} = timer:send_interval(1000, Name, send_int3),
  192:    ?line ok = get_mess(1500, send_int3, 2),
  193:    timer:cancel(Ref),
  194:    ?line nor = get_mess(1000, send_int3),  % We should receive only two
  195:    ?line unregister(Name).
  196:
<a name=send_interval4>  197:<b>send_interval4</b></a>(doc) -&gt; "Test that send interval stops sending msg when the "
  198:			   "receiving process terminates.";
<a name=send_interval4>  199:<b>send_interval4</b></a>(suite) -&gt; [];
<a name=send_interval4><a name="200"></a>  200:<b>send_interval4</b></a>(Config) when list(Config) -&gt;
  201:    ?line timer:send_interval(500, one_time_only),
  202:    receive 
  203:	one_time_only -&gt; ok
  204:    end,
  205:    ?line timer_server ! {'EXIT', self(), normal}, % Should remove the timer
  206:    ?line timer:send_after(600, send_intv_ok),
  207:    ?line send_intv_ok = receive 
  208:			     Msg -&gt; Msg
  209:			 end.
<a name="210"></a>  210:
<a name=cancel1>  211:<b>cancel1</b></a>(doc) -&gt; "Test that we can cancel a timer.";
<a name=cancel1>  212:<b>cancel1</b></a>(suite) -&gt; [];
<a name=cancel1>  213:<b>cancel1</b></a>(Config) when list(Config) -&gt;
  214:    ?line {ok, Ref} = timer:send_after(1000, this_should_be_canceled),
  215:    ?line timer:cancel(Ref),
  216:    ?line nor = get_mess(2000, this_should_be_canceled). % We should rec 0 msgs
  217:
<a name=cancel2>  218:<b>cancel2</b></a>(doc) -&gt; "Test cancel/1 with bad argument.";
<a name=cancel2>  219:<b>cancel2</b></a>(suite) -&gt; [];
<a name=cancel2><a name="220"></a>  220:<b>cancel2</b></a>(Config) when list(Config) -&gt;
  221:    ?line {error, badarg} = timer:cancel(no_reference). 
  222:
<a name=tc>  223:<b>tc</b></a>(doc) -&gt; "Test sleep/1 and tc/3.";
<a name=tc>  224:<b>tc</b></a>(suite) -&gt; [];
<a name=tc>  225:<b>tc</b></a>(Config) when list(Config) -&gt;
  226:    % This should both sleep and tc 
  227:    ?line {Res, ok} = timer:tc(timer, sleep, [500]),  
  228:    ?line ok = 	if 
  229:		    Res &lt; 500*1000 -&gt; {too_early, Res};  % Too early
<a name="230"></a>  230:		    Res &gt; 800*1000 -&gt; {too_late, Res};  % Too much time
  231:		    true -&gt; ok
  232:		end,
  233:
  234:    ?line Sec = timer:seconds(4),
  235:    ?line Min = timer:minutes(4),
  236:    ?line Hour = timer:hours(4),
  237:    ?line MyRes = 4*1000 + 4*60*1000 + 4*60*60*1000,
  238:    ?line if  MyRes == Sec + Min + Hour -&gt; ok end,
  239:    ?line TimerRes = timer:hms(4,4,4),
<a name="240"></a>  240:    ?line if MyRes == TimerRes -&gt; ok end,
  241:    ok.
  242:
<a name=unique_refs>  243:<b>unique_refs</b></a>(doc) -&gt;
  244:    "Tests that cancellations of one-shot timers do not accidentally "
  245:	"cancel interval timers [OTP-2771].";
<a name=unique_refs>  246:<b>unique_refs</b></a>(suite) -&gt;
  247:    [];
<a name=unique_refs>  248:<b>unique_refs</b></a>(Config) when list(Config) -&gt;
  249:    ?line ITimers = repeat_send_interval(10),		% 10 interval timers
<a name="250"></a>  250:    ?line eat_refs(?MAXREF - ?REFMARG),
  251:    ?line set_and_cancel_one_shots(?REFMARG),
  252:    ?line NumLeft = num_timers(),
  253:    ?line io:format("~w timers left, should be 10\n", [NumLeft]),
  254:    ?line cancel(ITimers),
  255:    ?line receive_nisse(),
  256:    ?line 10 = NumLeft.
  257:
  258:
<a name=repeat_send_interval>  259:<b>repeat_send_interval</b></a>(0) -&gt;
<a name="260"></a>  260:    [];
<a name=repeat_send_interval>  261:<b>repeat_send_interval</b></a>(M) -&gt;
  262:    ?line {ok, Ref} = timer:send_interval(6000,self(), nisse),
  263:    ?line [Ref| repeat_send_interval(M - 1)].
  264:
<a name=eat_refs>  265:<b>eat_refs</b></a>(0) -&gt;
  266:    0;
<a name=eat_refs>  267:<b>eat_refs</b></a>(N) -&gt;
  268:    make_ref(),
  269:    eat_refs(N-1).
<a name="270"></a>  270:
<a name=set_and_cancel_one_shots>  271:<b>set_and_cancel_one_shots</b></a>(0) -&gt;
  272:    0;
<a name=set_and_cancel_one_shots>  273:<b>set_and_cancel_one_shots</b></a>(N) -&gt;
  274:    {ok, Ref} = timer:send_after(7000, self(), kalle),
  275:    %% Cancel twice
  276:    timer:cancel(Ref),			
  277:    timer:cancel(Ref),
  278:    set_and_cancel_one_shots(N-1).
  279:
<a name=cancel><a name="280"></a>  280:<b>cancel</b></a>([T| Ts]) -&gt;
  281:    ?line timer:cancel(T),
  282:    ?line cancel(Ts);
<a name=cancel>  283:<b>cancel</b></a>([]) -&gt;
  284:    ok.
  285:
<a name=num_timers>  286:<b>num_timers</b></a>() -&gt;
  287:    {{_, TotalTimers},{_, IntervalTimers}} = timer:get_status(),
  288:    TotalTimers.
  289:
<a name=receive_nisse><a name="290"></a>  290:<b>receive_nisse</b></a>() -&gt;    
  291:    receive
  292:	nisse -&gt;
  293:	    receive_nisse()
  294:    after 0 -&gt;
  295:	    ok
  296:    end.
  297:
  298:
<a name=get_mess>  299:<b>get_mess</b></a>(Time, Mess) -&gt; get_mess(Time, Mess, 1).
<a name=get_mess><a name="300"></a>  300:<b>get_mess</b></a>(_, _, 0) -&gt; ok;  % Received
<a name=get_mess>  301:<b>get_mess</b></a>(Time, Mess, N) -&gt;
  302:    receive 
  303:	Mess -&gt; get_mess(Time, Mess, N-1)
  304:    after Time
  305:	  -&gt; nor   % Not Received
  306:    end.
  307:
<a name=forever>  308:<b>forever</b></a>() -&gt;
  309:    timer:sleep(1000),
<a name="310"></a>  310:    forever().
  311:
  312:
  313:<i>%</i>
  314:<i>% Testing for performance (on different implementations) of timers </i>
  315:<i>% </i>
  316:
<a name=timer_perf>  317:<b>timer_perf</b></a>(suite) -&gt; [];
<a name=timer_perf>  318:<b>timer_perf</b></a>(Config) when list(Config) -&gt;
  319:    performance(timer).
<a name="320"></a>  320:
<a name=performance>  321:<b>performance</b></a>(Mod) -&gt;
  322:    Save = process_flag(trap_exit, true),    
  323:    {Y,Mo,D} = date(),
  324:    {H,M,S} = time(),
  325:    io:format("Testing module '~p' Date: ~w/~w/~w ~w:~w:~w~n", 
  326:	      [Mod,Y,Mo,D,H,M,S]),
  327:    Result = big_test(Mod),
  328:    report_result(Result).
  329:
<a name=big_test><a name="330"></a>  330:<b>big_test</b></a>(M) -&gt;
  331:    Load_Pids = start_nrev(20, M),   % Increase if more load wanted :)
  332: 
  333:    apply(M, sleep, [9000]),
  334:    LPids = spawn_timers(5, M, 10000, 5),
  335:
  336:    apply(M, sleep, [4000]),
  337:    MPids = spawn_timers(10, M, 1000, 6),
  338:
  339:    apply(M, sleep, [3500]),
<a name="340"></a>  340:    SPids = spawn_timers(15, M, 100, 3),
  341:
  342:    Res = wait(SPids ++ MPids ++ LPids, [], 0, M),
  343:    
  344:    lists:foreach(fun(Pid) -&gt; exit(Pid, kill) end, Load_Pids),
  345:    Res.
  346:
<a name=wait>  347:<b>wait</b></a>([], Res, N, M) -&gt;
  348:    {Res, N};
<a name=wait>  349:<b>wait</b></a>(Pids, ResList, N, M) -&gt;
<a name="350"></a>  350:    receive
  351:	{Pid, ok, Res, T} -&gt;
  352:	    wait(lists:delete(Pid, Pids), [{T, Res} | ResList], N, M);
  353:	{Pid, Error}-&gt;
  354:	    ?line test_server:fail(Error),
  355:	    wait(lists:delete(Pid, Pids), ResList, N+1, M);
  356:	{'EXIT', Pid, Normal} -&gt;
  357:	    wait(lists:delete(Pid, Pids), ResList, N, M);
  358:	{'EXIT', Pid, Reason} -&gt;
  359:    	    ?line test_server:fail(Reason),
<a name="360"></a>  360:	    wait(lists:delete(Pid, Pids), ResList, N+1, M)
  361:    end.
  362:
<a name=spawn_timers>  363:<b>spawn_timers</b></a>(0, M, T, NI) -&gt;
  364:    [];
<a name=spawn_timers>  365:<b>spawn_timers</b></a>(N, M, T, NumIter) -&gt;
  366:    apply(M, sleep, [120*N]),
  367:    Pid1 = spawn_link(?MODULE, timer, [apply, M, T, self()]),
  368:    Pid2 = spawn_link(?MODULE, timer, [interval, M, T, self(), NumIter]),
  369:    [Pid1, Pid2 | spawn_timers(N-1, M, T, NumIter)].
<a name="370"></a>  370:
<a name=timer>  371:<b>timer</b></a>(apply, Mod, T, Pid) -&gt;
  372:    Before = system_time(),
  373:    {ok, Ref} = apply(Mod, apply_after, [T, ?MODULE, send, [self(), done]]),
  374:    receive 
  375:	done -&gt;
  376:	    After = system_time(),
  377:	    Pid ! {self(), ok, (After-Before) div 1000, T}
  378:    after T*3 + 300 -&gt;   % Watch dog
  379:	    io:format("WARNING TIMER WATCHDOG timed out: ~w ~n", [T]),
<a name="380"></a>  380:	    timer:cancel(Ref),
  381:	    Pid ! {self(), watch_dog_timed_out}
  382:    end.
  383:
<a name=timer>  384:<b>timer</b></a>(interval, Mod, T, Pid, NumIter) -&gt;
  385:    Before = system_time(),
  386:    {ok, Ref} = apply(Mod, apply_interval, [T, ?MODULE, send, [self(), done]]),
  387:    timer_irec(Before, T, {0, NumIter}, [], {Pid, Mod, Ref}).
  388:
<a name=timer_irec>  389:<b>timer_irec</b></a>(Start, T, {N, N}, Res, {Pid, Mod, Ref}) -&gt;
<a name="390"></a>  390:    Now = system_time(),
  391:    apply(Mod, cancel, [Ref]),
  392:    Min = lists:min(Res),
  393:    Max = lists:max(Res),
  394:    Tot = lists:sum(Res),
  395:    Pid ! {self(), ok, {N, Tot, Tot div N, Min, Max}, T};
  396:
<a name=timer_irec>  397:<b>timer_irec</b></a>(Start, T, {N, Max}, Res, {Pid, Mod, Ref}) -&gt;
  398:    receive
  399:	done -&gt;
<a name="400"></a>  400:	    Now = system_time(),
  401:	    Elapsed = (Now - (Start + (N*T*1000))) div 1000,
  402:<i>%	    io:format("~w Now ~w Started ~w Elap ~w~n", [T,Now,Start,Elapsed]),</i>
  403:	    timer_irec(Start, T,
  404:		       {N+1, Max},
  405:		       [Elapsed | Res],
  406:		       {Pid, Mod, Ref})
  407:    after T*3 + 300 -&gt;
  408:	    apply(Mod, cancel, [Ref]),
  409:	    io:format("WARNING: TIMER WATCHDOG timed out &lt;Interval&gt;~w~n",[T]),
<a name="410"></a>  410:	    Pid ! {self(), timer_watchdog_timed_out_in_interlval_test}  
  411:    end.
  412:
  413:<i>%% ------------------------------------------------------- %%</i>
  414:<i>%%  Small last generator</i>
  415:
<a name=start_nrev>  416:<b>start_nrev</b></a>(0, _) -&gt;
  417:    [];
  418:
<a name=start_nrev>  419:<b>start_nrev</b></a>(N, M) -&gt;
<a name="420"></a>  420:    Pid = spawn_link(?MODULE, do_nrev, [N, M]),
  421:    [Pid | start_nrev(N-1, M)].
  422:
<a name=do_nrev>  423:<b>do_nrev</b></a>(Sleep, Mod) -&gt;
  424:    apply(Mod, sleep, [50 * Sleep]),
  425:    test(1000,"abcdefghijklmnopqrstuvxyz1234"),
  426:    ok.
  427:
<a name=test>  428:<b>test</b></a>(0,_) -&gt;
  429:    true;
<a name=test><a name="430"></a>  430:<b>test</b></a>(N,L) -&gt;
  431:    nrev(L),
  432:    test(N - 1, L).
  433:
<a name=nrev>  434:<b>nrev</b></a>([]) -&gt;
  435:    [];
<a name=nrev>  436:<b>nrev</b></a>([H|T]) -&gt;
  437:    append(nrev(T), [H]).
  438:    
<a name=append>  439:<b>append</b></a>([H|T],Z) -&gt;
<a name="440"></a>  440:	[H|append(T,Z)];
<a name=append>  441:<b>append</b></a>([],X) -&gt;
  442:	X.
  443:
<a name=system_time>  444:<b>system_time</b></a>() -&gt;    
  445:    {M,S,U} = erlang:now(),
  446:    1000000*(M*1000000 + S) + U.
  447:
  448:<i>%% ------------------------------------------------------- %%</i>
  449:
<a name=report_result><a name="450"></a>  450:<b>report_result</b></a>({Res, 0}) -&gt;
  451:<i>%    io:format("DEBUG0 all ~p ~n", [Res]),</i>
  452:    {A_List, I_List} = split_list(Res, [], []),
  453:    A_val = calc_a_val(A_List),
  454:    I_val = calc_i_val(I_List),
  455:    print_report(A_val, I_val),
  456:    ok;
  457:
<a name=report_result>  458:<b>report_result</b></a>({Head, N}) -&gt;
  459:    io:format("Test Failed: Number of internal tmo ~w~n", [N]),
<a name="460"></a>  460:    ?line test_server:fail({Head, N}).
  461:
<a name=split_list>  462:<b>split_list</b></a>([], AL, IL) -&gt;
  463:    {AL, IL};
<a name=split_list>  464:<b>split_list</b></a>([{T, {N, Tot, A, Min, Max}} | Rest], AL, IL) -&gt;
  465:    split_list(Rest, AL, [{T, {N, Tot, A, Min, Max}} | IL]);
<a name=split_list>  466:<b>split_list</b></a>([Head | Rest], AL, IL) -&gt;
  467:    split_list(Rest, [Head | AL], IL).
  468:
<a name=split>  469:<b>split</b></a>([{T, Res} | R]) -&gt;
<a name="470"></a>  470:    split(R, {{T,[Res]}, {T*10,[]}, {T*100,[]}}).
  471:
<a name=split>  472:<b>split</b></a>([{T, Res} | R], {{T,S}, M, L}) -&gt;
  473:    split(R, {{T,[Res|S]}, M, L});
  474:
<a name=split>  475:<b>split</b></a>([{T, Res} | R], {S, {T,M}, L}) -&gt;
  476:    split(R, {S, {T, [Res|M]}, L});
  477:
<a name=split>  478:<b>split</b></a>([{T, Res} | R], {S, M, {T,L}}) -&gt;
  479:    split(R, {S, M, {T, [Res|L]}});
<a name="480"></a>  480:
<a name=split>  481:<b>split</b></a>(Done, Vals) -&gt;
  482:    Vals.
  483:
<a name=calc_a_val>  484:<b>calc_a_val</b></a>(List) -&gt;
  485:    New = lists:sort(List),
  486:    {{T1, S}, {T2, M}, {T3, L}} = split(New),
  487:    S2 = {length(S), lists:max(S), lists:min(S), 
  488:	  lists:sum(S) div length(S)},
  489:    M2 = {length(M), lists:max(M), lists:min(M), 
<a name="490"></a>  490:	  lists:sum(M) div length(M)},
  491:    L2 = {length(L), lists:max(L), lists:min(L), 
  492:	  lists:sum(L) div length(L)},
  493:    [{T1, S2}, {T2, M2}, {T3, L2}].
  494:
<a name=calc_i_val>  495:<b>calc_i_val</b></a>(List) -&gt;
  496:    New =  lists:sort(List),
  497:    {{T1, S}, {T2, M}, {T3, L}} = split(New),
  498:    S2 = get_ivals(S),
  499:    M2 = get_ivals(M),
<a name="500"></a>  500:    L2 = get_ivals(L),
  501:    [{T1, S2}, {T2, M2}, {T3, L2}].
  502:
<a name=get_ivals>  503:<b>get_ivals</b></a>(List) -&gt;
  504:    Len = length(List),
  505:    Num = element(1, hd(List)), % Number of iterations
  506:
  507:    LTot = lists:map(fun(X) -&gt; element(2, X) end, List),
  508:    LAver= lists:map(fun(X) -&gt; element(3, X) end, List),
  509:    LMin = lists:map(fun(X) -&gt; element(4, X) end, List),
<a name="510"></a>  510:    LMax = lists:map(fun(X) -&gt; element(5, X) end, List),
  511:    
  512:    MaxTot  = lists:max(LTot),
  513:    MinTot  = lists:min(LTot),
  514:    AverTot = lists:sum(LTot) div Len,
  515:    
  516:    IterMax = lists:max(LMax),
  517:    IterMin = lists:min(LMin),
  518:    IterAver= AverTot div Num,
  519:
<a name="520"></a>  520:    {Len, Num,
  521:     {MaxTot, MinTot, AverTot}, 
  522:     {IterMax, IterMin, IterAver}}.
  523:
  524:
<a name=print_report>  525:<b>print_report</b></a>(A_L, I_L) -&gt;
  526:    io:format("~nRESULTS from timer test~n~n",[]),
  527:    io:format("Time out times for send_after~n~n", []),
  528:    io:format("Time No of tests  Max    Min  Average~n",[]),
  529:    print_aval(A_L),
<a name="530"></a>  530:    io:format("Time out times for send_interval~n~n", []),
  531:    io:format("Time No.tests  No.intvals TotMax TotMin TotAver  MaxI   MinI  AverI~n", []),
  532:    print_ival(I_L).
  533:
<a name=print_aval>  534:<b>print_aval</b></a>([]) -&gt;
  535:    io:format("~n~n", []);
<a name=print_aval>  536:<b>print_aval</b></a>([{T, {L, Max, Min, Aver}}|R]) -&gt;
  537:    io:format("~5w ~8w ~6w ~6w ~8w ~n", 
  538:	      [T,L,Max,Min,Aver]),
  539:    print_aval(R).
<a name="540"></a>  540:
<a name=print_ival>  541:<b>print_ival</b></a>([]) -&gt;
  542:    io:format("~n", []);
<a name=print_ival>  543:<b>print_ival</b></a>([{T, {Len, Num, 
  544:		 {MaxT, MinT, AverT},
  545:		 {MaxI, MinI, AverI}}}|R]) -&gt;
  546:    io:format("~5w ~6w ~10w ~8w ~6w ~6w ~6w ~6w ~6w~n", 
  547:	      [T,Len,Num,MaxT,MinT,AverT, MaxI, MinI, AverI]),
  548:    print_ival(R).
  549:
<a name=send><a name="550"></a>  550:<b>send</b></a>(Pid, Msg) -&gt;
  551:    Pid ! Msg.
</pre>
<hr size=1><i>The transformation of this file (552 lines) took 0.02 seconds</i><br>
</body>
</html>

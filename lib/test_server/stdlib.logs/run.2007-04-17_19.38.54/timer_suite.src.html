<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head><title>/usr/home/jlouis/hacking/test_server/stdlib_test/timer_SUITE.erl</title></head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
    1:<i>%% ``The contents of this file are subject to the Erlang Public License,</i>
    2:<i>%% Version 1.1, (the "License"); you may not use this file except in</i>
    3:<i>%% compliance with the License. You should have received a copy of the</i>
    4:<i>%% Erlang Public License along with this software. If not, it can be</i>
    5:<i>%% retrieved via the world wide web at http://www.erlang.org/.</i>
    6:<i>%% </i>
    7:<i>%% Software distributed under the License is distributed on an "AS IS"</i>
    8:<i>%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See</i>
    9:<i>%% the License for the specific language governing rights and limitations</i>
<a name="10"></a>   10:<i>%% under the License.</i>
   11:<i>%% </i>
   12:<i>%% The Initial Developer of the Original Code is Ericsson Utvecklings AB.</i>
   13:<i>%% Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings</i>
   14:<i>%% AB. All Rights Reserved.''</i>
   15:<i>%% </i>
   16:<i>%%     $Id$</i>
   17:<i>%%</i>
   18:-<b>module</b>(timer_SUITE).
   19:
<a name="20"></a>   20:-<b>export</b>([all/1]).
   21:-<b>export</b>([do_big_test/1]).
   22:-<b>export</b>([big_test/1, collect/3, i_t/3, a_t/2]).
   23:-<b>export</b>([do_nrev/1, internal_watchdog/2]).
   24:
   25:-<b>include</b>("test_server.hrl").
   26:
   27:<i>%% Test suite for timer module. This is a really nasty test it runs a</i>
   28:<i>%% lot of timeouts and then checks in the end if any of them was</i>
   29:<i>%% trigggered too early or if any late timeouts was much too</i>
<a name="30"></a>   30:<i>%% late. What should be added is more testing of the interface</i>
   31:<i>%% functions I guess. But I don't have time for that now.</i>
   32:<i>%%</i>
   33:<i>%% Expect it to run for at least 5-10 minutes!</i>
   34:<i>%% Except for VxWorks of course, where a couple of hours is more apropriate...</i>
   35:
   36:
   37:<i>%% The timer_SUITE includes only one test case, the "do_big_test".  The</i>
   38:<i>%% "do_big_test" test orders a large number of timeouts and measures how</i>
   39:<i>%% exact the timeouts arrives. To simulate a system under load there is</i>
<a name="40"></a>   40:<i>%% also a number of other concurrent processes running "nrev" at the same</i>
   41:<i>%% time. The result is analyzed afterwards by trying to check if the</i>
   42:<i>%% measured values are reasonable. It is hard to determine what is</i>
   43:<i>%% reasonable on different machines therefore the test can sometimes</i>
   44:<i>%% fail, even though the timer module is ok. I have checked against</i>
   45:<i>%% previous versions of the timer module (which contained bugs) and it</i>
   46:<i>%% seems it fails every time when running the buggy timer modules.</i>
   47:<i>%% </i>
   48:<i>%% The solution is to rewrite the test suite. Possible strategies for a</i>
   49:<i>%% rewrite: smarter math on the measuring data, test cases with varying</i>
<a name="50"></a>   50:<i>%% amount of load. The test suite should also include tests that test the</i>
   51:<i>%% interface of the timer module.</i>
   52:
<a name=all>   53:<b>all</b></a>(suite) -&gt; {req,[stdlib],[do_big_test]}.
   54:
   55:<i>%% ------------------------------------------------------- %%</i>
   56:
<a name=do_big_test>   57:<b>do_big_test</b></a>(suite) -&gt; {req,[speed_sensitive,{time,320}]};
<a name=do_big_test>   58:<b>do_big_test</b></a>(TConfig) when list(TConfig) -&gt;
   59:    Save = process_flag(trap_exit, true),
<a name="60"></a>   60:    Result = case os:type() of
   61:		 vxworks -&gt;
   62:		     big_test(10);
   63:		 _ -&gt;
   64:		     big_test(200)
   65:	     end,
   66:    process_flag(trap_exit, Save),
   67:    report_result(Result).
   68:
<a name=report_result>   69:<b>report_result</b></a>(ok) -&gt; ok;
<a name=report_result><a name="70"></a>   70:<b>report_result</b></a>(Error) -&gt; ?line test_server:fail(Error).
   71:
   72:<i>%% ------------------------------------------------------- %%</i>
   73:
<a name=big_test>   74:<b>big_test</b></a>(N) -&gt;
   75:    C = start_collect(),
   76:    system_time(), system_time(), system_time(),
   77:    A1 = element(2, erlang:now()),
   78:    A2 = A1 * 3,
   79:    A3 = element(3, erlang:now()),
<a name="80"></a>   80:    random:seed(A1, A2, A3),
   81:    random:uniform(100),random:uniform(100),random:uniform(100),
   82:
   83:    big_loop(C, N, []),
   84:
   85:    %%C ! print_report,
   86:    C ! {self(), get_report},
   87:    Report = receive
   88:		 {report, R} -&gt;
   89:		     R
<a name="90"></a>   90:	     end,
   91:    C ! stop,
   92:    receive
   93:	{'EXIT', C, normal} -&gt;
   94:	    ok
   95:    end,
   96:    print_report(Report),
   97:    Result = analyze_report(Report),
   98:    %%io:format("big_test is done: ~w~n", [Result]),
   99:    Result.
<a name="100"></a>  100:    
<a name=big_loop>  101:<b>big_loop</b></a>(C, 0, []) -&gt;
  102:    %%io:format("All processes are done!~n", []),
  103:    ok;
<a name=big_loop>  104:<b>big_loop</b></a>(C, 0, Pids) -&gt;
  105:    %%ok = io:format("Loop done, ~w processes remaining~n", [length(Pids)]),
  106:    %% wait for remaining processes
  107:    receive
  108:	{'EXIT', Pid, done} -&gt;
  109:	    big_loop(C, 0, lists:delete(Pid, Pids));
<a name="110"></a>  110:	{'EXIT', Pid, Error} -&gt;
  111:	    ?line ok = io:format("XXX Pid ~w died with reason ~p~n",
  112:				 [Pid, Error]),
  113:	    big_loop(C, 0, lists:delete(Pid, Pids))
  114:    end;
<a name=big_loop>  115:<b>big_loop</b></a>(C, N, Pids) -&gt;
  116:    %% First reap any processes that are done.
  117:    receive
  118:	{'EXIT', Pid, done} -&gt;
  119:	    big_loop(C, N, lists:delete(Pid, Pids));
<a name="120"></a>  120:	{'EXIT', Pid, Error} -&gt;
  121:	    ?line ok =io:format("XXX Internal error: Pid ~w died, reason ~p~n",
  122:				 [Pid, Error]),
  123:	    big_loop(C, N, lists:delete(Pid, Pids))
  124:    after 0 -&gt;
  125:
  126:	    %% maybe start an interval timer test
  127:	    Pids1 = maybe_start_i_test(Pids, C, random:uniform(4)),
  128:	    
  129:	    %% start 1-4 "after" tests
<a name="130"></a>  130:	    Pids2 = start_after_test(Pids1, C, random:uniform(4)),
  131:	    %%Pids2=Pids1,
  132:
  133:	    %% wait a little while
  134:	    timer:sleep(random:uniform(200)*10),
  135:
  136:	    %% spawn zero, one or two nrev to get some load ;-/
  137:	    Pids3 = start_nrev(Pids2, random:uniform(100)),
  138:	    
  139:	    big_loop(C, N-1, Pids3)
<a name="140"></a>  140:    end.
  141:
  142:
<a name=start_nrev>  143:<b>start_nrev</b></a>(Pids, N) when N &lt; 25 -&gt;
  144:    Pids;
<a name=start_nrev>  145:<b>start_nrev</b></a>(Pids, N) when N &lt; 75 -&gt;
  146:    [spawn_link(timer_SUITE, do_nrev, [1])|Pids];
<a name=start_nrev>  147:<b>start_nrev</b></a>(Pids, N) -&gt;
  148:    NrevPid1 = spawn_link(timer_SUITE, do_nrev, [random:uniform(1000)*10]),
  149:    NrevPid2 = spawn_link(timer_SUITE, do_nrev, [1]),
<a name="150"></a>  150:    [NrevPid1,NrevPid2|Pids].
  151:    
  152:
<a name=start_after_test>  153:<b>start_after_test</b></a>(Pids, C, 1) -&gt;
  154:    TO1 = random:uniform(100)*100,
  155:    [s_a_t(C, TO1)|Pids];
<a name=start_after_test>  156:<b>start_after_test</b></a>(Pids, C, 2) -&gt;
  157:    TO1 = random:uniform(100)*100,
  158:    TO2 = TO1 div random:uniform(3) + 200,
  159:    [s_a_t(C, TO1),s_a_t(C, TO2)|Pids];
<a name=start_after_test><a name="160"></a>  160:<b>start_after_test</b></a>(Pids, C, N) -&gt;
  161:    TO1 = random:uniform(100)*100,
  162:    start_after_test([s_a_t(C, TO1)|Pids], C, N-1).
  163:
<a name=s_a_t>  164:<b>s_a_t</b></a>(C, TimeOut) -&gt;
  165:    spawn_link(timer_SUITE, a_t, [C, TimeOut]).
  166:
<a name=a_t>  167:<b>a_t</b></a>(C, TimeOut) -&gt;
  168:    start_watchdog(self(), TimeOut),
  169:    Start = system_time(),
<a name="170"></a>  170:    timer:send_after(TimeOut, self(), now),
  171:    receive
  172:	now -&gt;
  173:	    Stop = system_time(),
  174:	    report(C, Start,Stop,TimeOut),
  175:	    exit(done);
  176:	watchdog -&gt;
  177:	    Stop = system_time(),
  178:	    report(C, Start,Stop,TimeOut),
  179:	    ?line ok = io:format("Internal watchdog timeout (a), not good!!~n",
<a name="180"></a>  180:				 []),
  181:	    exit(done)
  182:    end.
  183:
  184:
<a name=maybe_start_i_test>  185:<b>maybe_start_i_test</b></a>(Pids, C, 1) -&gt;
  186:    %% ok do it
  187:    TOI = random:uniform(100)*100,
  188:    CountI = random:uniform(10) + 3,                      % at least 4 times
  189:    [spawn_link(timer_SUITE, i_t, [C, TOI, CountI])|Pids];
<a name=maybe_start_i_test><a name="190"></a>  190:<b>maybe_start_i_test</b></a>(Pids, C, _) -&gt;
  191:    Pids.
  192:
<a name=i_t>  193:<b>i_t</b></a>(C, TimeOut, Times) -&gt;
  194:    start_watchdog(self(), TimeOut*Times),
  195:    Start = system_time(),
  196:    {ok, Ref} = timer:send_interval(TimeOut, interval),
  197:    i_wait(Start, Start, 1, TimeOut, Times, Ref, C).
  198:
<a name=i_wait>  199:<b>i_wait</b></a>(Start, Prev, Times, TimeOut, Times, Ref, C) -&gt;
<a name="200"></a>  200:    receive
  201:	interval -&gt;
  202:	    Now = system_time(),
  203:	    report_interval(C, {final,Times}, Start, Prev, Now, TimeOut),
  204:	    timer:cancel(Ref),
  205:	    exit(done);
  206:	watchdog -&gt;
  207:	    Now = system_time(),
  208:	    report_interval(C, {final,Times}, Start, Prev, Now, TimeOut),
  209:	    timer:cancel(Ref),
<a name="210"></a>  210:	    ?line ok = io:format("Internal watchdog timeout (i), not good!!~n",
  211:				 []),
  212:	    exit(done)
  213:    end;
<a name=i_wait>  214:<b>i_wait</b></a>(Start, Prev, Count, TimeOut, Times, Ref, C) -&gt;
  215:    receive
  216:	interval -&gt;
  217:	    Now = system_time(),
  218:	    report_interval(C, Count, Start, Prev, Now, TimeOut),
  219:	    i_wait(Start, Now, Count+1, TimeOut, Times, Ref, C);
<a name="220"></a>  220:	watchdog -&gt;
  221:	    Now = system_time(),
  222:	    report_interval(C, {final,Count}, Start, Prev, Now, TimeOut),
  223:	    ?line ok = io:format("Internal watchdog timeout (j), not good!!~n",
  224:				 []),
  225:	    exit(done)
  226:    end.
  227:
<a name=report>  228:<b>report</b></a>(C, Start, Stop, Time) -&gt;
  229:    C ! {a_sample, Start, Stop, Time}.
<a name=report_interval><a name="230"></a>  230:<b>report_interval</b></a>(C, Count, Start, Prev, Now, TimeOut) -&gt;
  231:    C ! {i_sample, Count, Start, Prev, Now, TimeOut}.
  232:
  233:<i>%% ------------------------------------------------------- %%</i>
  234:
  235:<i>%% internal watchdog</i>
<a name=start_watchdog>  236:<b>start_watchdog</b></a>(Pid, TimeOut) -&gt;
  237:    spawn_link(timer_SUITE, internal_watchdog, [Pid, 3*TimeOut+1000]).
  238:
<a name=internal_watchdog>  239:<b>internal_watchdog</b></a>(Pid, TimeOut) -&gt;
<a name="240"></a>  240:    receive
  241:    after TimeOut -&gt;
  242:	    Pid ! watchdog,
  243:	    exit(normal)
  244:    end.
  245:
  246:<i>%% ------------------------------------------------------- %%</i>
  247:
  248:-<b>record</b>(stat, {n=0,max=0,min=min,avg=0}).
  249:
<a name=start_collect><a name="250"></a>  250:<b>start_collect</b></a>() -&gt;
  251:    spawn_link(timer_SUITE, collect, [0,{0,new_update(),new_update()},[]]).
  252:
<a name=collect>  253:<b>collect</b></a>(N, {E,A,B}, I) -&gt;
  254:    receive
  255:	{a_sample, Start, Stop, Time} when Stop - Start &gt; Time -&gt;
  256:	    collect(N+1, {E,update(Stop-Start-Time,A),B}, I);
  257:	{a_sample, Start, Stop, Time} when Stop - Start &lt; Time -&gt;
  258:	    collect(N+1, {E,A,update(Time-Stop+Start,B)}, I);
  259:	{a_sample, Start, Stop, Time} -&gt;
<a name="260"></a>  260:	    collect(N+1, {E+1,A,B}, I);
  261:	{i_sample, {final,Count}, Start, Prev, Now, TimeOut} -&gt;
  262:	    IntervDiff = Now - Prev - TimeOut,
  263:	    Drift = Now - (Count*TimeOut) - Start,
  264:	    collect(N, {E,A,B}, [{{final,Count},IntervDiff,Drift}|I]);
  265:	{i_sample, Count, Start, Prev, Now, TimeOut} -&gt;
  266:	    IntervDiff = Now - Prev - TimeOut,
  267:	    Drift = Now - (Count*TimeOut) - Start,
  268:	    collect(N, {E,A,B}, [{Count,IntervDiff,Drift}|I]);
  269:	print_report -&gt;
<a name="270"></a>  270:	    print_report({E,A,B,I}),
  271:	    collect(N,{E,A,B}, I);
  272:	{Pid, get_report} when pid(Pid) -&gt;
  273:	    Pid ! {report, {E, A, B, I}},
  274:	    collect(N,{E,A,B}, I);
  275:	reset -&gt;
  276:	    collect(0, {0,new_update(),new_update()}, []);
  277:	stop -&gt;
  278:	    exit(normal);
  279:	Other -&gt;
<a name="280"></a>  280:	    collect(N, {E,A,B}, I)
  281:    end.
  282:
<a name=new_update>  283:<b>new_update</b></a>() -&gt; #stat{}.
<a name=update>  284:<b>update</b></a>(New, Stat) when New &gt; Stat#stat.max -&gt;
  285:    Stat#stat{n=Stat#stat.n + 1, max=New, avg=(New+Stat#stat.avg) div 2};
<a name=update>  286:<b>update</b></a>(New, Stat) when New &lt; Stat#stat.min -&gt;
  287:    Stat#stat{n=Stat#stat.n + 1, min=New, avg=(New+Stat#stat.avg) div 2};
<a name=update>  288:<b>update</b></a>(New, Stat) -&gt;
  289:    Stat#stat{n=Stat#stat.n + 1, avg=(New+Stat#stat.avg) div 2}.
<a name="290"></a>  290:
  291:<i>%update(New, {N,Max,Min,Avg}) when New&gt;Max -&gt;</i>
  292:<i>%    {N+1,New,Min,(New+Avg) div 2};</i>
  293:<i>%update(New, {N,Max,Min,Avg}) when New&lt;Min -&gt;</i>
  294:<i>%    {N+1,Max,New,(New+Avg) div 2};</i>
  295:<i>%update(New, {N,Max,Min,Avg}) -&gt;</i>
  296:<i>%    {N+1,Max,Min,(New+Avg) div 2}.</i>
  297:
<a name=print_report>  298:<b>print_report</b></a>({E,LateS,EarlyS,I}) -&gt;
  299:    Early = EarlyS#stat.n, Late = LateS#stat.n,
<a name="300"></a>  300:    Total = E + Early + Late,
  301:    io:format("~nOn total of ~w timeouts, there were ~w exact, ~w "
  302:	      "late and ~w early.~n", [Total, E, Late, Early]),
  303:    io:format("Late stats (N,Max,Min,Avg): ~w~nEarly stats: ~w~n",
  304:	      [LateS, EarlyS]),
  305:    IntervS = collect_interval_final_stats(I),
  306:    io:format("Interval stats (Max,Min,Avg): ~w~n", [IntervS]),
  307:    ok.
  308:
<a name=collect_interval_final_stats>  309:<b>collect_interval_final_stats</b></a>(I) -&gt;
<a name="310"></a>  310:    collect_interval_final_stats(I, 0, min, 0).
<a name=collect_interval_final_stats>  311:<b>collect_interval_final_stats</b></a>([], Max, Min, Avg) -&gt;
  312:    {Max, Min, Avg};
<a name=collect_interval_final_stats>  313:<b>collect_interval_final_stats</b></a>([{{final,Count},_,Dev}|T], Max, Min, Avg) -&gt;
  314:    NMax = if Dev&gt;Max -&gt; Dev; true -&gt; Max end,
  315:    NMin = if Dev&lt;Min -&gt; Dev; true -&gt; Min end,
  316:    collect_interval_final_stats(T, NMax, NMin, (Dev+Avg) div 2);
<a name=collect_interval_final_stats>  317:<b>collect_interval_final_stats</b></a>([H|T], Max, Min, Avg) -&gt;
  318:    collect_interval_final_stats(T, Max, Min, Avg).
  319:
<a name=analyze_report><a name="320"></a>  320:<b>analyze_report</b></a>({E,LateS,EarlyS,I}) -&gt;
  321:    Early = EarlyS#stat.n, Late = LateS#stat.n,
  322:    Total = E + Early + Late,
  323:    IntervS = collect_interval_final_stats(I),
  324:    Res1 = min_and_early_check(E, Early, Late, element(2,IntervS)),
  325:    Res2 = abnormal_max_check(LateS#stat.max, element(1,IntervS)),
  326:    res_combine(ok, [Res1, Res2]).
  327:
  328:-<b>define</b>(ok_i_min, -100).
  329:-<b>define</b>(ok_max, 8000).
<a name="330"></a>  330:-<b>define</b>(ok_i_max, 4000).
  331:
  332:<i>%% ok as long as Early == 0 and IntervMin &gt;= ok_interv_min</i>
<a name=min_and_early_check>  333:<b>min_and_early_check</b></a>(Exact, 0, Late, IntervMin) when IntervMin &gt;= ?ok_i_min -&gt;
  334:    ok;
<a name=min_and_early_check>  335:<b>min_and_early_check</b></a>(Exact, Early, Late, IntervMin) when IntervMin &gt;= ?ok_i_min -&gt;
  336:    {error, {early_timeouts, Early}};
<a name=min_and_early_check>  337:<b>min_and_early_check</b></a>(Exact, 0, Late, IntervMin) -&gt;
  338:    {error, early_interval_timeout};
<a name=min_and_early_check>  339:<b>min_and_early_check</b></a>(Exact, Early, Late, IntervMin) -&gt;
<a name="340"></a>  340:    {error, [{early_timeouts, Early},{error, early_interval_timeout}]}.
  341:
<a name=abnormal_max_check>  342:<b>abnormal_max_check</b></a>(LateMax, IntMax) when LateMax &lt; ?ok_max,
  343:                                         IntMax &lt; ?ok_i_max -&gt;
  344:    ok;
<a name=abnormal_max_check>  345:<b>abnormal_max_check</b></a>(LateMax, IntMax) when IntMax &lt; ?ok_i_max -&gt;
  346:    {error, {big_late_max, LateMax}};
<a name=abnormal_max_check>  347:<b>abnormal_max_check</b></a>(LateMax, IntMax) when LateMax &lt; ?ok_max -&gt;
  348:    {error, {big_interval_max, IntMax}};
<a name=abnormal_max_check>  349:<b>abnormal_max_check</b></a>(LateMax, IntMax) -&gt;
<a name="350"></a>  350:    {error, [{big_late_max, LateMax},{big_interval_max, IntMax}]}.
  351:
<a name=res_combine>  352:<b>res_combine</b></a>(Res, []) -&gt;
  353:    Res;
<a name=res_combine>  354:<b>res_combine</b></a>(Res, [ok|T]) -&gt;
  355:    res_combine(Res, T);
<a name=res_combine>  356:<b>res_combine</b></a>(ok, [{error,What}|T]) -&gt;
  357:    res_combine({error,What}, T);
<a name=res_combine>  358:<b>res_combine</b></a>({error,Es}, [{error,E}|T]) -&gt;
  359:    res_combine({error,lists:flatten([E,Es])}, T).
<a name="360"></a>  360:
  361:
<a name=system_time>  362:<b>system_time</b></a>() -&gt;
  363:    %%element(1, statistics(wall_clock)).
  364:    {M,S,U} = erlang:now(),
  365:    1000000000 * M + 1000 * S + (U div 1000).
  366:
  367:<i>%% ------------------------------------------------------- %%</i>
  368:
<a name=do_nrev>  369:<b>do_nrev</b></a>(Sleep) -&gt;
<a name="370"></a>  370:    timer:sleep(Sleep),
  371:    test(1000,"abcdefghijklmnopqrstuvxyz1234"),
  372:    exit(done).
  373:
<a name=test>  374:<b>test</b></a>(0,_) -&gt;
  375:    true;
<a name=test>  376:<b>test</b></a>(N,L) -&gt;
  377:    nrev(L),
  378:    test(N - 1, L).
  379:
<a name=nrev><a name="380"></a>  380:<b>nrev</b></a>([]) -&gt;
  381:    [];
<a name=nrev>  382:<b>nrev</b></a>([H|T]) -&gt;
  383:    append(nrev(T), [H]).
  384:    
<a name=append>  385:<b>append</b></a>([H|T],Z) -&gt;
  386:	[H|append(T,Z)];
<a name=append>  387:<b>append</b></a>([],X) -&gt;
  388:	X.
  389:
<a name="390"></a>  390:<i>%% ------------------------------------------------------- %%</i>
</pre>
<hr size=1><i>The transformation of this file (391 lines) took 0.01 seconds</i><br>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head><title>/usr/home/jlouis/hacking/test_server/stdlib_test/slave_SUITE.erl</title></head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
    1:<i>%% ``The contents of this file are subject to the Erlang Public License,</i>
    2:<i>%% Version 1.1, (the "License"); you may not use this file except in</i>
    3:<i>%% compliance with the License. You should have received a copy of the</i>
    4:<i>%% Erlang Public License along with this software. If not, it can be</i>
    5:<i>%% retrieved via the world wide web at http://www.erlang.org/.</i>
    6:<i>%% </i>
    7:<i>%% Software distributed under the License is distributed on an "AS IS"</i>
    8:<i>%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See</i>
    9:<i>%% the License for the specific language governing rights and limitations</i>
<a name="10"></a>   10:<i>%% under the License.</i>
   11:<i>%% </i>
   12:<i>%% The Initial Developer of the Original Code is Ericsson Utvecklings AB.</i>
   13:<i>%% Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings</i>
   14:<i>%% AB. All Rights Reserved.''</i>
   15:<i>%% </i>
   16:<i>%%     $Id$</i>
   17:<i>%%</i>
   18:-<b>module</b>(slave_SUITE).
   19:
<a name="20"></a>   20:-<b>include</b>("test_server.hrl").
   21:
   22:-<b>export</b>([all/1, t_start/1, t_start_link/1,
   23:	 start_link_nodedown/1, errors/1]).
   24:
   25:<i>%% Internal exports.</i>
   26:-<b>export</b>([fun_init/1, test_errors/1]).
   27:-<b>export</b>([timeout_test/1, auth_test/1, rsh_test/1, start_a_slave/3]).
   28:
<a name=all>   29:<b>all</b></a>(suite) -&gt;
<a name="30"></a>   30:    [t_start_link, start_link_nodedown, t_start, errors].
   31:
<a name=t_start_link>   32:<b>t_start_link</b></a>(suite) -&gt; [];
<a name=t_start_link>   33:<b>t_start_link</b></a>(Config) when list(Config) -&gt;
   34:    ?line Dog = test_server:timetrap(test_server:seconds(20)),
   35:
   36:    %% Define useful variables.
   37:
   38:    ?line Host = host(),
   39:    ?line Slave1 = node_name(Host, slave1),
<a name="40"></a>   40:    ?line Slave2 = node_name(Host, slave2),
   41:
   42:    %% Test slave:start_link() with one, two, and three arguments.
   43:
   44:    ?line ThisNode = node(),
   45:    ?line {error, {already_running, ThisNode}} = slave:start_link(Host),
   46:    ?line {ok, Slave1} = slave:start_link(Host, slave1),
   47:    ?line {ok, Slave2} = slave:start_link(Host, slave2, "-my_option 42"),
   48:    ?line {ok, [["42"]]} = rpc:call(Slave2, init, get_argument, [my_option]),
   49:
<a name="50"></a>   50:    %% Kill the two slave nodes and verify that they are dead.
   51:
   52:    ?line rpc:cast(Slave1, erlang, halt, []),
   53:    ?line rpc:cast(Slave2, erlang, halt, []),
   54:    ?line is_dead(Slave1),
   55:    ?line is_dead(Slave2),
   56:
   57:    %% Start two slave nodes from another process and verify that
   58:    %% the slaves die when that process terminates.
   59:
<a name="60"></a>   60:    Parent = self(),
   61:    Pid = fun_spawn(fun () -&gt;
   62:			    {ok, Slave1} = slave:start_link(Host, slave1),
   63:			    {ok, Slave2} = slave:start_link(Host, slave2),
   64:			    Parent ! slaves_started,
   65:			    receive never -&gt; ok end
   66:		    end),
   67:    ?line receive slaves_started -&gt; ok end,
   68:    ?line process_flag(trap_exit, true),
   69:    ?line is_alive(Slave1),
<a name="70"></a>   70:    ?line is_alive(Slave2),
   71:    ?line exit(Pid, kill),
   72:    ?line receive {'EXIT', Pid, killed} -&gt; ok end,
   73:    ?line test_server:sleep(250),
   74:    ?line is_dead(Slave1),
   75:    ?line is_dead(Slave2),
   76:		  
   77:    ?line test_server:timetrap_cancel(Dog),
   78:    ok.
   79:
<a name="80"></a>   80:<i>%% Test that slave:start_link() works when the master exits.</i>
   81:
<a name=start_link_nodedown>   82:<b>start_link_nodedown</b></a>(suite) -&gt; [];
<a name=start_link_nodedown>   83:<b>start_link_nodedown</b></a>(Config) when list(Config) -&gt;
   84:    ?line Dog = test_server:timetrap(test_server:seconds(20)),
   85:
   86:    %% Define useful variables.
   87:
   88:    ?line Host = host(),
   89:    ?line Master = node_name(Host, my_master),
<a name="90"></a>   90:    ?line Slave = node_name(Host, my_slave),
   91:
   92:    ?line Pa = "-pa " ++ filename:dirname(code:which(?MODULE)),
   93:    ?line {ok, Master} = slave:start_link(Host, my_master, Pa),
   94:    ?line spawn(Master, ?MODULE, start_a_slave, [self(), Host, my_slave]),
   95:    ?line {reply, {ok, _Node}} = receive Any -&gt; Any end,
   96:    
   97:    ?line rpc:call(Master, erlang, halt, []),
   98:    ?line receive after 200 -&gt; ok end,
   99:    ?line pang = net_adm:ping(Slave),
<a name="100"></a>  100:
  101:    ?line test_server:timetrap_cancel(Dog),
  102:    ok.
  103:
<a name=start_a_slave>  104:<b>start_a_slave</b></a>(ReplyTo, Host, Name) -&gt;
  105:    ReplyTo ! {reply, slave:start_link(Host, Name)},
  106:    receive never -&gt; ok end.
  107:
  108:<i>%% Test slave:start().</i>
  109:
<a name=t_start><a name="110"></a>  110:<b>t_start</b></a>(suite) -&gt; [];
<a name=t_start>  111:<b>t_start</b></a>(Config) when list(Config) -&gt;
  112:    ?line Dog = test_server:timetrap(test_server:seconds(20)),
  113:    
  114:    %% Define useful variables.
  115:
  116:    ?line Host = host(),
  117:    ?line Slave1 = node_name(Host, slave1),
  118:    ?line Slave2 = node_name(Host, slave2),
  119:
<a name="120"></a>  120:    %% By running all tests from this master node which is linked
  121:    %% to this test case, we ensure that all slaves are killed
  122:    %% if this test case fails.  (If they are not, and therefore further
  123:    %% test cases fail, there is a bug in slave.)
  124:
  125:    ?line {ok, Master} = slave:start_link(Host, master),
  126:    
  127:    %% Test slave:start() with one, two, and three arguments.
  128:
  129:    ?line ThisNode = node(),
<a name="130"></a>  130:    ?line {error, {already_running, ThisNode}} = slave:start(Host),
  131:    ?line {ok, Slave1} = rpc:call(Master, slave, start, [Host, slave1]),
  132:    ?line {ok, Slave2} = rpc:call(Master, slave, start,
  133:				  [Host, slave2, "-my_option 42"]),
  134:    ?line {ok, [["42"]]} = rpc:call(Slave2, init, get_argument, [my_option]),
  135:
  136:    %% Test that a slave terminates when its master node terminates.
  137:
  138:    ?line ok = slave:stop(Slave2),
  139:    ?line is_dead(Slave2),
<a name="140"></a>  140:    ?line {ok, Slave2} = rpc:call(Slave1, slave, start, [Host, slave2]),
  141:    ?line is_alive(Slave2),
  142:    ?line rpc:call(Slave1, erlang, halt, []),	% Kill master.
  143:    receive after 1000 -&gt; ok end,		% Make sure slaves have noticed
  144:						% their dead master.
  145:    ?line is_dead(Slave1),
  146:    ?line is_dead(Slave2),			% Slave should be dead, too.
  147:
  148:    %% Kill all slaves and verify that they are dead.
  149:
<a name="150"></a>  150:    ?line ok = slave:stop(Slave1),
  151:    ?line ok = slave:stop(Slave2),
  152:    ?line is_dead(Slave1),
  153:    ?line is_dead(Slave2),
  154:
  155:    ?line test_server:timetrap_cancel(Dog),
  156:    ok.
  157:
  158:<i>%% Test the various error conditions in parallell (since the timeout</i>
  159:<i>%% in slave is 32 seconds).</i>
<a name="160"></a>  160:
<a name=errors>  161:<b>errors</b></a>(suite) -&gt; [];
<a name=errors>  162:<b>errors</b></a>(Config) when list(Config) -&gt;
  163:    ?line Dog = test_server:timetrap(test_server:seconds(50)),
  164:
  165:    ?line process_flag(trap_exit, true),
  166:    ?line Pa = filename:dirname(code:which(?MODULE)),
  167:    ?line {ok, Master} = slave_start_link(host(), master,
  168:					  "-rsh no_rsh_program -pa "++Pa++
  169:					  " -env ERL_CRASH_DUMP erl_crash_dump.master"),
<a name="170"></a>  170:    ?line Pids = rpc:call(Master, ?MODULE, test_errors, [self()]),
  171:    ?line wait_for_result(Pids),
  172:
  173:    ?line test_server:timetrap_cancel(Dog),
  174:    ok.
  175:
<a name=wait_for_result>  176:<b>wait_for_result</b></a>([]) -&gt;
  177:    ok;
<a name=wait_for_result>  178:<b>wait_for_result</b></a>(Pids) -&gt;
  179:    ?line receive
<a name="180"></a>  180:	      {'EXIT', Pid, normal} -&gt;
  181:		  io:format("Process ~p terminated", [Pid]),
  182:		  wait_for_result(lists:delete(Pid, Pids));
  183:	      {'EXIT', _, Reason} -&gt;
  184:		  exit(Reason)
  185:	  end.
  186:
<a name=show_process_info>  187:<b>show_process_info</b></a>(Pid) -&gt;
  188:    io:format("~p: ~p", [Pid, catch process_info(Pid, initial_call)]).
  189:
<a name=test_errors><a name="190"></a>  190:<b>test_errors</b></a>(ResultTo) -&gt;
  191:    %% Sigh!  We use ordinary spawn instead of fun_spawn/1 to be able
  192:    %% identify the processes by their initial call.
  193:    ?line P1 = spawn(?MODULE, timeout_test, [ResultTo]),
  194:    ?line P2 = spawn(?MODULE, auth_test, [ResultTo]),
  195:    ?line P3 = spawn(?MODULE, rsh_test, [ResultTo]),
  196:    Pids =[P1, P2, P3],
  197:    ?line lists:foreach(fun show_process_info/1, Pids),
  198:    Pids.
  199:
<a name=timeout_test><a name="200"></a>  200:<b>timeout_test</b></a>(ResultTo) -&gt;
  201:    link(ResultTo),
  202:    ?line {error, timeout} = slave:start(host(), slave1, "-boot no_boot_script").
  203:
<a name=auth_test>  204:<b>auth_test</b></a>(ResultTo) -&gt;
  205:    link(ResultTo),
  206:    ?line {error, timeout} = slave:start(host(), slave2,
  207:					 "-setcookie definitely_not_a_cookie").
  208:
<a name=rsh_test>  209:<b>rsh_test</b></a>(ResultTo) -&gt;
<a name="210"></a>  210:    link(ResultTo),
  211:    ?line {error, no_rsh} = slave:start(super, slave3).
  212:
  213:
  214:<i>%%% Utilities.    </i>
  215:
<a name=is_alive>  216:<b>is_alive</b></a>(Node) -&gt;
  217:    {started, _} = rpc:call(Node, init, get_status, []).
  218:
<a name=is_dead>  219:<b>is_dead</b></a>(Node) -&gt;
<a name="220"></a>  220:    {badrpc, nodedown} = rpc:call(Node, init, get_status, []).
  221:
<a name=node_name>  222:<b>node_name</b></a>(Host, Name) -&gt;
  223:    list_to_atom(lists:concat([Name, "@", Host])).
  224:
<a name=host>  225:<b>host</b></a>() -&gt;
  226:    from($@, atom_to_list(node())).
  227:
<a name=from>  228:<b>from</b></a>(H, [H | T]) -&gt; T;
<a name=from>  229:<b>from</b></a>(H, [_ | T]) -&gt; from(H, T);
<a name=from><a name="230"></a>  230:<b>from</b></a>(_H, []) -&gt; [].
  231:
<a name=slave_start_link>  232:<b>slave_start_link</b></a>(Host, Name, Args) -&gt;
  233:    case slave:start_link(Host, Name, Args) of
  234:	{ok, Node} -&gt;
  235:	    {ok, Node};
  236:	Other -&gt;
  237:	    io:format("slave:start_link(~p, ~p, ~p) -&gt; ~p",
  238:		      [Host, Name, Args, Other])
  239:    end.
<a name="240"></a>  240:
<a name=fun_spawn>  241:<b>fun_spawn</b></a>(Fun) -&gt;
  242:    spawn_link(?MODULE, fun_init, [Fun]).
  243:
<a name=fun_init>  244:<b>fun_init</b></a>(Fun) -&gt;
  245:    Fun().
</pre>
<hr size=1><i>The transformation of this file (246 lines) took 0.01 seconds</i><br>
</body>
</html>

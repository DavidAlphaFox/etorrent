----------------------------------------------------------------------
-- This is a list of what To Do before a release is ready to be made.
----------------------------------------------------------------------
* Peer Master
- Implement rounds
  Implement choking/unchoking rounds in the Peer Master.
- Implement a simpler bad map
  Rather than keep the kill-message (Which is always normal), keep a
   counter and make the counter be used.

* Torrent_Peer
- Implement BitField lists
  We should implement the bitfield lists there are to be sent and
   retrieved when we first communicate.
- Handle retrieval of bitfield messages in the peer.
- Handle retrieval of piece messages.
  We still need to handle the case that one piece is retrieved fully,
  while we have requested something from another piece. We must then
  construct the 2nd piece GBT so we can keep that coming in. It means
  we may need to change part of this code.
- Tell torrent_state when we have a piece downloaded correctly.
  This can both update "amount left" state and remove the piece from
   the list the pid has running.

- Implement our local request queue.

* TorrentControl
- Simplify state machine.
  The state machine can be simplified a great deal if you are smart
   and inject most torrent information via the start_link message.

* Torrent_State (Maybe Torrent_peer_manager)
- Handle when a peer goes down.
- Write code for handling a completed piece
  When a piece is completed, it should be removed from
   S#state.piece_assignments.

* Connection management
- Implement seeding
  We are not doing anything specific to take care of seeding right
  now. This must obviously be cared for. The way to do it is in the
  torrent_state process.
- Implement torrent_piecemap:pieces_downloaded/1
  The function asks to the piecemap what pieces we have downloaded. We
  must return a correct answer.
- Implement code for putback when a connection dies.
  If a connection dies, all pieces on its request table should be
  remapped to be eligible for others to work on.
- Fix connection_manager
  We need to fix the state code for the connection manager. It has some
  state tables that obviously needs to be managed. But it has to be
  simplified a lot. And it really can. Mapping of pids to torrents and
  peerids should be handled by a separate process which only has this as
  the primary goal.

* General stuff
- Reduce the number of ets tables
  Fix and reduce the number of ets tables to a constant amount. This
  will allow us to scale into post-1000 concurrent torrents.
- Add license facts,
  I am not sure if it is going to be GPL or BSD-licensed.

- Add author facts
  They are there, but are incorrect in a lot of files. They must
  be corrected.

* DOCUMENTATION!
- Pick functions at random, and document what they are doing.
  It is /especially/ important to document library calls and
   non-standard internal functions in OTP modules.
- Make an INSTALL and README document for release.
- Build a google-code page for the release.
- Push release 1.0 into SVN at google.

------------------------------------------------------------
VERSION 2.0
------------------------------------------------------------
* Make torrent_piecemap request data in a rarest first scheme.
  Currently torrent_piecemap requests data in a scheme which is
  "pick-random-piece". It should use rarest first instead to drive
  up the download speed and make torrent health better.

* TorrentManager
- Check if a torrent is duplicate.
  We must check if a given torrent file which has just been added is a
  duplicate of a torrent we already manage. If this is the case, then we
  should just ignore it.

* Cleanups
- Decide what to do if we connect multiply to the same IP

* PeerIds
- Is one billion peerids enough? Think about making the number higher
  If the client becomes popular, this is important to change. We can
   /easily/ increase the number to a more correct level.

------------------------------------------------------------
VERSION 3.0
------------------------------------------------------------
* Implement the fast extension.
  This will require some thought as there may be a very changed
   implementation in the peer clients.

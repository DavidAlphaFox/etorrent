%%% Local Variables:
%%% mode: todoo
%%% End:
----------------------------------------------------------------------
-- This is a list of what To Do before a release is ready to be made.
--   Keep the style please. Can be read with emacs org-mode
----------------------------------------------------------------------

* When peers die, putback it's assigned chunks [Milestone: 0.8]
   Currently this does not happen properly. It should be handled by
   the peer group process.

* When a peer chokes update #chunk correctly [Milestone: 0.8]
   Currently, when a peer chokes us, something goes very wrong. I
   think this is the main reason as to why we see memory leaks.

* Test incoming connections [Milestone: 0.8]
   This code has seen very little traversal. Change the IP of the test
   machine so it can be reached outside the network and do some
   incoming connection testing as well.

   UPDATE: This is not yet implemented at all. We should reimplement
   it.

* Test endgame [Milestone 0.8]
   The endgame has not been tested much. Do some more testing.

   Read really carefully about when we enter endgame mode. I think
   I've seen a stray error where endgame mode got entered too
   quickly. Try to optimize it.

* What happens when 2 peers store the same piece at same time [Milestone: 0.9]
   This was an XXX inside the code. But it needs some serious thinking
   first as there is no easy fix for this.

* When initializing the tracker, get it to start right away. [Milestone: 0.9]
   We send it a 'start_now/0' message at the moment and that can
   possibly be removed.

* Find a way to cap the number of 'open' chunks [Milestone: 0.9]
   If we just allow the thing to open up chunks as it sees fit, we
   will use a lot of memory very quickly.

   UPDATE: Might be related to another bug. Check that it still occurs
   at 0.9.

* Add another state for #piece records [Milestone: 0.9]
   The state 'chunked_no_left' should indicate that the piece has been
   chunked, but there are no chunks left to pick from it. The state is
   introduced when we empty the #chunk record with not_fetched for the
   #piece and it is reintroduced in putback_chunks so we may again
   pick from it. Also, in the endgame, we should pick off from this
   state.

   It turns out to be an optimization, so put it into 0.9 for now.

* Set a kernel parameter for timer:start() [Milestone: 0.9]
   This is mentioned in timer(3erl), so better heed it.

* Let the system start with +Ktrue and +A 256 [Milestone: 0.9]
   Will greatly enhance the performance of the application.

* Eradicate XXX and TODO [Milestone 1.0]
   Go through the code and remove all XXX and TODOs remaining
   there. There are a few that have been added when I find something
   disgusting in the code base.

* What should we do about bad peers? [Milestone: 1.0]
   Currently bad peers are those which are already connected. We ought
   to keep a list of baddies and blacklist them for some time if we
   don't like them anymore.

* Profile and minimize the critical path [Milestone: 1.1]
   It looks like the critical path takes a wee bit too many clock
   cycles. It might be possible to cut it down considerably by
   profiling and optimizing that path.

   I want to do something about it, but not right now. Hence in
   Milestone 1.1.

* Use passive sockets [Milestone: 1.1]
   We need to use passive sockets at some point. The reason is that
   active sockets have no flow control, and the granularity of whole
   packets are bad from a choke/unchoke perspective. The code that
   needs change is rather contained, luckily, and can be placed in
   peer_communication.

   An even more sinister idea: change to active sockets when the rate
   of the peer exceeds a certain set amount to cut down the amount of
   processing needed. We *do* have some flow control as a peer will
   only send things we requested, so a peer can't overflow us by more
   than that anyway.

* DOCUMENTATION!
- Pick functions at random, and document what they are doing.
  It is /especially/ important to document library calls and
   non-standard internal functions in OTP modules.

* TorrentPeerMaster [Milestone: not decided]
- Figure out a better choking/unchoking algorithm.
  The current algorithm is the original one. We should look for a
   better algorithm and implement that. Suggestions for digging:
     ** Azureus
     ** Mainline
     ** Bittornado
     ** rtorrent

* Cleanups
- Decide what to do if we connect multiply to the same IP

* Temporary IP-ban on errors [Milestone: 1.1]
  If we find an error on a given peer, ban him temporarily for some
   time.

* ROBUSTNESS [Milestone: 1.2]
- In general, robustness is not really taken care of. We ought to make
  the system more robust by not relying so much on Pids etc.
- What happens if process X dies
  Go through all processes, and think about what happens if it
   dies. Ensure that the system is robust.


